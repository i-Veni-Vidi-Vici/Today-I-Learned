# 파이썬
## PEP
- ```
  Python Enhancement Proposals
  ```
- 파이썬 개선 제안서
- 파이썬의 디자인 결정을 문서화한 파이썬의 주요 개발 프로세스
### PEP8 
- Style Guide for Python Code
- Python 코드에 대한 스타일 가이드
#### 들여쓰기
- 들여쓰기는 4개의 공백을 사용
- 첫번째 줄에 인자가 있으면 수직정렬
- 첫번째 줄에 인자가 없으면, 추가로 들여쓰기(4개)
- 추가적인 들여쓰기가 없어도 다음행과 구분이 되는경우 없어도 가능
- ```python
  # Correct:
  foo = long_function_name(var_one, var_two,
      var_three, var_four)		#수직정렬o
  def long_function_name(
        var_one, var_two, var_three,	#추가로 들여쓰기
        var_four):
    print(var_one)
  if (this_is_one_thing and
    that_is_another_thing):	#들여쓰기x
    do_something()		
  if (this_is_one_thing
        and that_is_another_thing):	#들여쓰기o
    do_something()
  # Wrong:
  foo = long_function_name(var_one, var_two,
    var_three, var_four)	#수직정렬x
  def long_function_name(
    var_one, var_two, var_three,
    var_four):	#추가 들여쓰기가 없어, 다음행과 구분이 안됨x
    print(var_one)
    ```
- 괄호위치는 마지막줄이나, 첫번째줄 둘다가능
- ```python
  # Correct:
    my_list = [	#마지막줄
        1, 2, 3,
        4, 5, 6,
        ]
    my_list = [	#첫번째 줄
        1, 2, 3,
        4, 5, 6,
    ]
   ```
#### 탭 or 스페이스
- 스페이스가 선호되는 들여쓰기 방식
- 탭과 스페이스를 혼합x
#### 최대 줄길이
- 모든 행은 최대 ```79```자로 제한
- 코드가 길어지는 경우 적절히 백슬래시```(\)```로 줄바꿈 가능(다음줄로 연결)
- ```python
    # Example
    with open('/path/to/some/file/you/want/to/read') as file_1, \
       open('/path/to/some/file/being/written', 'w') as file_2:
      file_2.write(file_1.read())
    ```
#### 이항 연산자 줄바꿈
- ```python
  # Wrong:
  # operators sit far away from their operands
  income = (gross_wages +	# 연산자가 뒤에있어 울퉁불퉁 보기 다소 불편함
            taxable_interest +
            (dividends - qualified_dividends) -
            ira_deduction -
            student_loan_interest)
  # Correct:
  # easy to match operators with operands
  income = (gross_wages
            + taxable_interest	# 이항연산자를 앞에 두는것이 직관적임
            + (dividends - qualified_dividends)
            - ira_deduction
            - student_loan_interest)
  ```
#### 빈줄
- 최상위 함수와 클래스 정의를 두 개의 빈줄로 둘러쌈
- 클래스 내의 메서드 정의는 한줄로 둘러쌈
- 관련된 그룹을 구분하기 위해 빈 줄을 추가하거나 생략가능
- ```python
  # Correct:
  def a():
      pass


  class b():

      def c():
          pass

      def d():
          pass


  class e():
      pass
  ```
#### Source File Encoding
- 파이썬의 배포판의 코드는 항상 ```UTF-8``` 을 사용
- 인코딩 선언이 없어야 함
#### Imports
- Import는 각각의 줄로 구분해야함
- import는 항상 파일의 맨위에 작성
- Wildcard```(*)``` imports는 가급적 사용자제
- ```python
  # Correct:
  import os
  import sys
  from subprocess import Popen, PIPE

  # Wrong:
  import sys, os
  from <module> import *	# (*)사용 자제
  ```


#### Module Level Dunder Names
- 두개의 언더바```(__)```가  앞뒤로있는 이름은 ```from __future__ imports``` 제외한 모든 imports 앞에 작성되어야함
- 파이썬은 docstring(주석)을 제외하고 다른코드 앞에 future-imports가 반드시 먼저 작성되어야함
- ```python
  """This is the example module.

  This module does stuff.	#docstring
  """
  from __future__ import barry_as_FLUFL

  __all__ = ['a', 'b', 'c']
  __version__ = '0.1'
  __author__ = 'Cardinal Biggles'

  import os
  import sys
  ```
  ####  문자열 따옴표
- '," 어느것을 사용해도 상관없음
- 이중 따옴표시에 서로 다른 따옴표 사용
- 세번따옴표시에 docstring PEP 257 규약대로 항상 큰 따옴표(")를 사용

#### 공백
- 괄호 바로안쪽에 공백 x
- ```python
  # Correct:
  spam(ham[1], {eggs: 2})
  # Wrong:
  spam( ham[ 1 ], { eggs: 2 } )
  - 콤마와 다음 괄호사이 공백x 
  # Correct:
  foo = (0,)
  # Wrong:
  bar = (0, )
  ```
- 콤마, 세미콜론, 콜론 바로 앞 공백x
- ```python
  # Correct:
  if x == 4: print x, y; x, y = y, x
  # Wrong:
  if x == 4 : print x , y ; x , y = y , x
  ```
- 슬라이스의 콜론에서 수식이나 함수가 들어갔을 때 동일한 공백 사용
- ```python
  # Correct:
  ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
  ham[lower:upper], ham[lower:upper:], ham[lower::step]
  ham[lower+offset : upper+offset]
  ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
  ham[lower + offset : upper + offset]
  # Wrong:
  ham[lower + offset:upper + offset]
  ham[1: 9], ham[1 :9], ham[1:9 :3]
  ham[lower : : upper]
  ham[ : upper]
  ```
- 함수 괄호옆 공백x
- ```python
  # Correct:
  spam(1)
  # Wrong:
  spam (1)
  ```
- 인덱싱, 슬라이싱 괄호 앞 공백x
- 함수 괄호옆 공백x
- ```python
  # Correct:
  dct['key'] = lst[index]
  # Wrong:
  dct ['key'] = lst [index]
  ```
- 연산자 주변에 둘 이상의 공백x
- 우선순위가 낮은 연산자 주변에만 공백o
- ```python
  # Correct:
  x = 1
  y = 2
  long_variable = 3
  # Wrong:
  x             = 1
  y             = 2
  long_variable = 3
  # Correct:
  i = i + 1
  submitted += 1
  x = x*2 - 1
  hypot2 = x*x + y*y
  c = (a+b) * (a-b)
  # Wrong:
  i=i+1
  submitted +=1
  x = x * 2 - 1
  hypot2 = x * x + y * y
  c = (a + b) * (a - b)
  ```
- 화살표 공백o
- ```python
  # Correct:
  def munge(input: AnyStr): ...
  def munge() -> PosInt: ...
  # Wrong:
  def munge(input:AnyStr): ...
  def munge()->PosInt: ...
  ```
- 주석없이 함수 매개변수의 기본값을 나타내는=사이 공백x
- 기본값에 대한 주석이 포함되어있으면 =사이 공백o
- ```python
  # Correct:
  def complex(real, imag=0.0):
      return magic(r=real, i=imag)
  # Wrong:
  def complex(real, imag = 0.0):
      return magic(r = real, i = imag)
  ```
- 같은 줄에 여러 문장x
- ```python
  # Correct:
  if foo == 'blah':
      do_blah_thing()
  do_one()
  do_two()
  do_three()
  # Wrong:
  if foo == 'blah': do_blah_thing()
  do_one(); do_two(); do_three()
  ```
- 때때로 if, for, while문을 적은 글자수로 한줄로 표현가능하면 권장은 하진않지만 작동은 가능
- ```python
  # Wrong:
  if foo == 'blah': do_blah_thing()
  for x in lst: total += x
  while t < 10: t = delay()
  # Wrong, Wrong:
  if foo == 'blah': do_blah_thing()
  else: do_non_blah_thing()

  try: something()
  finally: cleanup()

  do_one(); do_two(); do_three(long, argument,
                               list, like, this)

  if foo == 'blah': one(); two(); three()
  ```
#### 콤마 사용
- 후행에 콤마는 한 요소의 튜플을 만들때 필수라는 점을 제외하고 일반적으로 선택사항
- ```python
  # Correct:
  FILES = ('setup.cfg',)
  # Wrong:
  FILES = 'setup.cfg',
  ```
- 후행 콤마는 확장될 값에 유용하고, 종결괄호와 같은 줄에 사용x
- ```python
  # Correct:
  FILES = [
      'setup.cfg',
      'tox.ini',
      ]
  initialize(FILES,
             error=True,
             )
  # Wrong:
  FILES = ['setup.cfg', 'tox.ini',]
  initialize(FILES, error=True,)
  ```

#### 주석
- 코드와 모순되는 주석은 없는 것보다 안좋기 때문에 코드가 변경되면 주석을 항상 최신 상태를 유지
- 식별자가 아니라면 첫문자는 대문자(식별자의 대소문자 변경 금지)
- 블록 주석은 완전한 문장으로 구성된 하나 이상의 단락으로 구성되며, 각 문장은 마침표로 끝남
- 비영어권자만 읽는게 아니라면, 영어로 작성

##### Block 주석
- 블록 주석은 블록 주석 뒤에 오는 코드에 적용
- 코드와 같은 수준으로 들여쓰기
- 블록 주석 각 행은 #과 공백으로 시작
##### Inline 주석
- 인라인 주석은 적당히 사용
- 인라인 주석은 코드와 두 개 이상의 공백으로 구분
- #와 공백 하나로 시작
- 인라인 주석은 불필요하고, 당연한 것을 말할때 주의를 산만하게 함
- ```python
  # Wrong
  x = x + 1                 # Increment x
  # But sometimes, this is useful:
  x = x + 1                 # Compensate for border
  ```
##### Documentation Strings
- 모든 공용 모듈, 함수, 클래스 및 메서드에 대해서 작성
- 비공용 메서드에는 필요하지 않지만 메서드가 수행하는 작업설명에는 주석 작성
- 정의 라인 뒤에 표시되어야함 
- 1줄인 경우 """를 같은줄에 사용
- 1줄인 경우 함수/메서드의 매개변수를 반복 작성x
- ```python
  # Correct:
  def kos_root():
      """Return the pathname of the KOS root directory."""
      global _kos_root
      if _kos_root: return _kos_root
  # Wrong:
  def function(a, b):
      """function(a, b) -> list"""
  # Correct:
  def function(a, b):
      """Do X and return a list."""
  ```
- 2줄 이상인경우 각 인수를 별도의 행에 나열
- 2줄 이상 docstring(주석)에서는 후행의"""가 단독으로 사용
- ```python
  # Correct:
  def complex(real=0.0, imag=0.0):
      """Form a complex number.

      Keyword arguments:
      real -- the real part (default 0.0)
      imag -- the imaginary part (default 0.0)
      """
      if imag == 0.0 and real == 0.0:
          return complex_zero
      ...
  ```

#### 네이밍 컨벤션(Naming Convention) 
- 명명규칙
##### 스네이크 케이스(Snake Case)
- 파이썬에서 변수명과 함수명에서 사용하며, 각 단어를 밑줄 ```(_)```로 구분하여 표기하는 방식
클래스 이름- ```CapWords```
- 클래스이름은 각단어의 첫문자를 대문자로 표현
#### etc 
##### Java - 카멜 케이스(Camel Case)
- 카멜케이스는 낙타에서 유래되어 단어의 첫 단어의 시작은 소문자로 표기하고, 두번째 단어부터는 단어의 첫문자를 대문자로 표기하는 방식
##### 파스칼 케이스(Pascal Case)
- 카멜케이스와 비슷하지만 파스칼 케이스는 모든 단어의 첫문자를 대문자로 표기하는 방식 

## 타입 힌트(Type Hint)
- 파이썬은 대표적인 동적 타이핑언어이지만, 타입을 명시할 수 있는 타입 힌트가 존재
- 타입명시는 되지만, 강제로 지정하는게아니라 동적으로 작동될수 있어 주의가 필요
- 타입 명시가 안되있으면, 긴 코드에서 가독성이 떨어지고 에러발생 확률이 증가
- 변수는 변수 뒤에 콜론(:)을 붙이고 타입을 명시, 콜론 뒤에만 공백 한칸
- 함수의 리턴값에는 화살표(->) 사용, 화살표 양쪽으로 공백 한칸
- ```python
  a=1	# 타입지정x
  a: int=1	# 타입지정o
  def func(x: str) -> bool:	# 타입지정o
    pass
  c: str =1
  print(type(c))	# <class 'int'>출력
  ```

### typing 모듈
- typing 모듈로 조금더 구체적인 타입명시 가능

- ```python
  from typing import List, Set, Dict, Tuple
  num: List[int] = [1]
  unique_nums: Set[int] = {2, 3}
  Price: Dict[str, float] = {'a': 10, 'b': 50}
  Profile: Tuple[int, str, List[int]] = (25, "Byun", [177, 74])
  ```
#### 재할당이 불가능한 변수타입- Final
- ```python
  from typing import Final
  num: Final[int] = 10
  ```
#### 여러 타입- Union
- ```python
  from typing import Union
  
  
  def a(num: Union[int, float]) -> str:
      return str(num)
  a(1)  #'1'
  a(2.5)  #'2.5'
  ```
#### None을 사용하는 매개변수 - Optional
- ```python
  def a(b: str, num: Optional[int] = None) -> str:
      if num:
          return b * num
      else:
          return b
  ```
#### 함수의 매개변수와 리턴값 - Callable
- 함수의 매개변수와 리턴값을 명시
- 특히 함수를 매개변수로 받을때와 람다함수 사용시 주로 사용
- ```Callable[[매개변수 타입], 리턴 타입]```
- ```pyhton
  from typing import Callable


  def call(respon: Callable[[str], str], name: str) -> None:
      print(respon(name))
  respon: Callable[[str], str] = lambda name: name
  call(respon, "Byun")
  ```

#### 타입 추상화 - Iterable
- 함수의 매개변수의 타입을 명시할때 추상적으로 하는것이 좋은경우
- ```python
  from typing import Iterable


  def a(num: Iterable[int]) -> str:	# Iterable[int]로 인해, 제약없이 여러 데이터타입을 받을수있음
      return str(x) for x in num
  ```

#### 함수를 간단히 표현 - lambda
- 간단한 함수를 표현할때 사용
- ```lambda 매개변수: 표현식```
- ```python
  # 기본
  def cal(x):
      return print(x * 2)
  cal(2)
  # lambda 사용
  cal = lambda x:print(x * 2)
  cal(2)
  # 더 간단히 lambda 사용 (함수 이름 지정없이 호출을 한줄에)
  (lambda x:print(x * 2))(2)
  ```

#### map
- 리스트나 튜플의 원소들을 하나씩 함수에 적용시키는 함수
- 리스트로 리턴할시 ```list()```사용
- ```map(함수, 리스트 or 튜플)```
- ```python
  # 일반함수
  def cal(x):
      return x * 2
  print(list(map(cal,[1,2,3])))	# [2, 4, 6]
  # 람다사용
  cal = lambda x: x * 2
  print(list(map(cal,[1,2,3])))	# [2, 4, 6]
  # 더 간단한 람다사용
  print(list(map((lambda x: x * 2), [1,2,3])))	# [2, 4, 6]
  ```

