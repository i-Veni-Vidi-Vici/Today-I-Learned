# 파이썬
## PEP
- ```
  Python Enhancement Proposals
  ```
- 파이썬 개선 제안서
- 파이썬의 디자인 결정을 문서화한 파이썬의 주요 개발 프로세스
### PEP8 
- Style Guide for Python Code
- Python 코드에 대한 스타일 가이드
#### 들여쓰기
- 들여쓰기는 4개의 공백을 사용
- 첫번째 줄에 인자가 있으면 수직정렬
- 첫번째 줄에 인자가 없으면, 추가로 들여쓰기(4개)
- 추가적인 들여쓰기가 없어도 다음행과 구분이 되는경우 없어도 가능
- ```python
  # Correct:
  foo = long_function_name(var_one, var_two,
      var_three, var_four)		#수직정렬o
  def long_function_name(
        var_one, var_two, var_three,	#추가로 들여쓰기
        var_four):
    print(var_one)
  if (this_is_one_thing and
    that_is_another_thing):	#들여쓰기x
    do_something()		
  if (this_is_one_thing
        and that_is_another_thing):	#들여쓰기o
    do_something()
  # Wrong:
  foo = long_function_name(var_one, var_two,
    var_three, var_four)	#수직정렬x
  def long_function_name(
    var_one, var_two, var_three,
    var_four):	#추가 들여쓰기가 없어, 다음행과 구분이 안됨x
    print(var_one)
    ```
- 괄호위치는 마지막줄이나, 첫번째줄 둘다가능
- ```python
  # Correct:
    my_list = [	#마지막줄
        1, 2, 3,
        4, 5, 6,
        ]
    my_list = [	#첫번째 줄
        1, 2, 3,
        4, 5, 6,
    ]
   ```
#### 탭 or 스페이스
- 스페이스가 선호되는 들여쓰기 방식
- 탭과 스페이스를 혼합x
#### 최대 줄길이
- 모든 행은 최대 ```79```자로 제한
- 코드가 길어지는 경우 적절히 백슬래시```(\)```로 줄바꿈 가능(다음줄로 연결)
- ```python
    # Example
    with open('/path/to/some/file/you/want/to/read') as file_1, \
       open('/path/to/some/file/being/written', 'w') as file_2:
      file_2.write(file_1.read())
    ```
#### 이항 연산자 줄바꿈
- ```python
  # Wrong:
  # operators sit far away from their operands
  income = (gross_wages +	# 연산자가 뒤에있어 울퉁불퉁 보기 다소 불편함
            taxable_interest +
            (dividends - qualified_dividends) -
            ira_deduction -
            student_loan_interest)
  # Correct:
  # easy to match operators with operands
  income = (gross_wages
            + taxable_interest	# 이항연산자를 앞에 두는것이 직관적임
            + (dividends - qualified_dividends)
            - ira_deduction
            - student_loan_interest)
  ```
#### 빈줄
- 최상위 함수와 클래스 정의를 두 개의 빈줄로 둘러쌈
- 클래스 내의 메서드 정의는 한줄로 둘러쌈
- 관련된 그룹을 구분하기 위해 빈 줄을 추가하거나 생략가능
- ```python
  # Correct:
  def a():
      pass


  class b():

      def c():
          pass

      def d():
          pass


  class e():
      pass
  ```
#### Source File Encoding
- 파이썬의 배포판의 코드는 항상 ```UTF-8``` 을 사용
- 인코딩 선언이 없어야 함
#### Imports
- Import는 각각의 줄로 구분해야함
- import는 항상 파일의 맨위에 작성
- Wildcard```(*)``` imports는 가급적 사용자제
- ```python
  # Correct:
  import os
  import sys
  from subprocess import Popen, PIPE

  # Wrong:
  import sys, os
  from <module> import *	# (*)사용 자제
  ```


#### Module Level Dunder Names
- 두개의 언더바```(__)```가  앞뒤로있는 이름은 ```from __future__ imports``` 제외한 모든 imports 앞에 작성되어야함
- 파이썬은 docstring(주석)을 제외하고 다른코드 앞에 future-imports가 반드시 먼저 작성되어야함
- ```python
  """This is the example module.

  This module does stuff.	#docstring
  """
  from __future__ import barry_as_FLUFL

  __all__ = ['a', 'b', 'c']
  __version__ = '0.1'
  __author__ = 'Cardinal Biggles'

  import os
  import sys
  ```
  ####  문자열 따옴표
- '," 어느것을 사용해도 상관없음
- 이중 따옴표시에 서로 다른 따옴표 사용
- 세번따옴표시에 docstring PEP 257 규약대로 항상 큰 따옴표(")를 사용

#### 공백
- 괄호 바로안쪽에 공백 x
- ```python
  # Correct:
  spam(ham[1], {eggs: 2})
  # Wrong:
  spam( ham[ 1 ], { eggs: 2 } )
  - 콤마와 다음 괄호사이 공백x 
  # Correct:
  foo = (0,)
  # Wrong:
  bar = (0, )
  ```
- 콤마, 세미콜론, 콜론 바로 앞 공백x
- ```python
  # Correct:
  if x == 4: print x, y; x, y = y, x
  # Wrong:
  if x == 4 : print x , y ; x , y = y , x
  ```
- 슬라이스의 콜론에서 수식이나 함수가 들어갔을 때 동일한 공백 사용
- ```python
  # Correct:
  ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
  ham[lower:upper], ham[lower:upper:], ham[lower::step]
  ham[lower+offset : upper+offset]
  ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
  ham[lower + offset : upper + offset]
  # Wrong:
  ham[lower + offset:upper + offset]
  ham[1: 9], ham[1 :9], ham[1:9 :3]
  ham[lower : : upper]
  ham[ : upper]
  ```
- 함수 괄호옆 공백x
- ```python
  # Correct:
  spam(1)
  # Wrong:
  spam (1)
  ```
- 인덱싱, 슬라이싱 괄호 앞 공백x
- 함수 괄호옆 공백x
- ```python
  # Correct:
  dct['key'] = lst[index]
  # Wrong:
  dct ['key'] = lst [index]
  ```
- 연산자 주변에 둘 이상의 공백x
- 우선순위가 낮은 연산자 주변에만 공백o
- ```python
  # Correct:
  x = 1
  y = 2
  long_variable = 3
  # Wrong:
  x             = 1
  y             = 2
  long_variable = 3
  # Correct:
  i = i + 1
  submitted += 1
  x = x*2 - 1
  hypot2 = x*x + y*y
  c = (a+b) * (a-b)
  # Wrong:
  i=i+1
  submitted +=1
  x = x * 2 - 1
  hypot2 = x * x + y * y
  c = (a + b) * (a - b)
  ```
- 화살표 공백o
- ```python
  # Correct:
  def munge(input: AnyStr): ...
  def munge() -> PosInt: ...
  # Wrong:
  def munge(input:AnyStr): ...
  def munge()->PosInt: ...
  ```
- 주석없이 함수 매개변수의 기본값을 나타내는=사이 공백x
- 기본값에 대한 주석이 포함되어있으면 =사이 공백o
- ```python
  # Correct:
  def complex(real, imag=0.0):
      return magic(r=real, i=imag)
  # Wrong:
  def complex(real, imag = 0.0):
      return magic(r = real, i = imag)
  ```
- 같은 줄에 여러 문장x
- ```python
  # Correct:
  if foo == 'blah':
      do_blah_thing()
  do_one()
  do_two()
  do_three()
  # Wrong:
  if foo == 'blah': do_blah_thing()
  do_one(); do_two(); do_three()
  ```
- 때때로 if, for, while문을 적은 글자수로 한줄로 표현가능하면 권장은 하진않지만 작동은 가능
- ```python
  # Wrong:
  if foo == 'blah': do_blah_thing()
  for x in lst: total += x
  while t < 10: t = delay()
  # Wrong, Wrong:
  if foo == 'blah': do_blah_thing()
  else: do_non_blah_thing()

  try: something()
  finally: cleanup()

  do_one(); do_two(); do_three(long, argument,
                               list, like, this)

  if foo == 'blah': one(); two(); three()
  ```
#### 콤마 사용
- 후행에 콤마는 한 요소의 튜플을 만들때 필수라는 점을 제외하고 일반적으로 선택사항
- ```python
  # Correct:
  FILES = ('setup.cfg',)
  # Wrong:
  FILES = 'setup.cfg',
  ```
- 후행 콤마는 확장될 값에 유용하고, 종결괄호와 같은 줄에 사용x
- ```python
  # Correct:
  FILES = [
      'setup.cfg',
      'tox.ini',
      ]
  initialize(FILES,
             error=True,
             )
  # Wrong:
  FILES = ['setup.cfg', 'tox.ini',]
  initialize(FILES, error=True,)
  ```

#### 주석
- 코드와 모순되는 주석은 없는 것보다 안좋기 때문에 코드가 변경되면 주석을 항상 최신 상태를 유지
- 식별자가 아니라면 첫문자는 대문자(식별자의 대소문자 변경 금지)
- 블록 주석은 완전한 문장으로 구성된 하나 이상의 단락으로 구성되며, 각 문장은 마침표로 끝남
- 비영어권자만 읽는게 아니라면, 영어로 작성

##### Block 주석
- 블록 주석은 블록 주석 뒤에 오는 코드에 적용
- 코드와 같은 수준으로 들여쓰기
- 블록 주석 각 행은 #과 공백으로 시작
##### Inline 주석
- 인라인 주석은 적당히 사용
- 인라인 주석은 코드와 두 개 이상의 공백으로 구분
- #와 공백 하나로 시작
- 인라인 주석은 불필요하고, 당연한 것을 말할때 주의를 산만하게 함
- ```python
  # Wrong
  x = x + 1                 # Increment x
  # But sometimes, this is useful:
  x = x + 1                 # Compensate for border
  ```
##### Documentation Strings
- 모든 공용 모듈, 함수, 클래스 및 메서드에 대해서 작성
- 비공용 메서드에는 필요하지 않지만 메서드가 수행하는 작업설명에는 주석 작성
- 정의 라인 뒤에 표시되어야함 
- 1줄인 경우 """를 같은줄에 사용
- 1줄인 경우 함수/메서드의 매개변수를 반복 작성x
- ```python
  # Correct:
  def kos_root():
      """Return the pathname of the KOS root directory."""
      global _kos_root
      if _kos_root: return _kos_root
  # Wrong:
  def function(a, b):
      """function(a, b) -> list"""
  # Correct:
  def function(a, b):
      """Do X and return a list."""
  ```
- 2줄 이상인경우 각 인수를 별도의 행에 나열
- 2줄 이상 docstring(주석)에서는 후행의"""가 단독으로 사용
- ```python
  # Correct:
  def complex(real=0.0, imag=0.0):
      """Form a complex number.

      Keyword arguments:
      real -- the real part (default 0.0)
      imag -- the imaginary part (default 0.0)
      """
      if imag == 0.0 and real == 0.0:
          return complex_zero
      ...
  ```

#### 네이밍 컨벤션(Naming Convention) 
- 명명규칙
##### 스네이크 케이스(Snake Case)
- 파이썬에서 변수명과 함수명에서 사용하며, 각 단어를 밑줄 ```(_)```로 구분하여 표기하는 방식
클래스 이름- ```CapWords```
- 클래스이름은 각단어의 첫문자를 대문자로 표현
#### etc 
##### Java - 카멜 케이스(Camel Case)
- 카멜케이스는 낙타에서 유래되어 단어의 첫 단어의 시작은 소문자로 표기하고, 두번째 단어부터는 단어의 첫문자를 대문자로 표기하는 방식
##### 파스칼 케이스(Pascal Case)
- 카멜케이스와 비슷하지만 파스칼 케이스는 모든 단어의 첫문자를 대문자로 표기하는 방식 

## 타입 힌트(Type Hint)
- 파이썬은 대표적인 동적 타이핑언어이지만, 타입을 명시할 수 있는 타입 힌트가 존재
- 타입명시는 되지만, 강제로 지정하는게아니라 동적으로 작동될수 있어 주의가 필요
- 타입 명시가 안되있으면, 긴 코드에서 가독성이 떨어지고 에러발생 확률이 증가
- 변수는 변수 뒤에 콜론(:)을 붙이고 타입을 명시, 콜론 뒤에만 공백 한칸
- 함수의 리턴값에는 화살표(->) 사용, 화살표 양쪽으로 공백 한칸
- ```python
  a=1	# 타입지정x
  a: int=1	# 타입지정o
  def func(x: str) -> bool:	# 타입지정o
    pass
  c: str =1
  print(type(c))	# <class 'int'>출력
  ```

### typing 모듈
- typing 모듈로 조금더 구체적인 타입명시 가능

- ```python
  from typing import List, Set, Dict, Tuple
  num: List[int] = [1]
  unique_nums: Set[int] = {2, 3}
  Price: Dict[str, float] = {'a': 10, 'b': 50}
  Profile: Tuple[int, str, List[int]] = (25, "Byun", [177, 74])
  ```
#### 재할당이 불가능한 변수타입- Final
- ```python
  from typing import Final
  num: Final[int] = 10
  ```
#### 여러 타입- Union
- ```python
  from typing import Union
  
  
  def a(num: Union[int, float]) -> str:
      return str(num)
  a(1)  #'1'
  a(2.5)  #'2.5'
  ```
#### None을 사용하는 매개변수 - Optional
- ```python
  def a(b: str, num: Optional[int] = None) -> str:
      if num:
          return b * num
      else:
          return b
  ```
#### 함수의 매개변수와 리턴값 - Callable
- 함수의 매개변수와 리턴값을 명시
- 특히 함수를 매개변수로 받을때와 람다함수 사용시 주로 사용
- ```Callable[[매개변수 타입], 리턴 타입]```
- ```pyhton
  from typing import Callable


  def call(respon: Callable[[str], str], name: str) -> None:
      print(respon(name))
  respon: Callable[[str], str] = lambda name: name
  call(respon, "Byun")
  ```

#### 타입 추상화 - Iterable
- 함수의 매개변수의 타입을 명시할때 추상적으로 하는것이 좋은경우
- ```python
  from typing import Iterable


  def a(num: Iterable[int]) -> str:	# Iterable[int]로 인해, 제약없이 여러 데이터타입을 받을수있음
      return str(x) for x in num
  ```

#### 함수를 간단히 표현 - lambda
- 간단한 함수를 표현할때 사용
- ```lambda 매개변수: 표현식```
- ```python
  # 기본
  def cal(x):
      return print(x * 2)
  cal(2)
  # lambda 사용
  cal = lambda x:print(x * 2)
  cal(2)
  # 더 간단히 lambda 사용 (함수 이름 지정없이 호출을 한줄에)
  (lambda x:print(x * 2))(2)
  ```

#### map
- 리스트나 튜플의 원소들을 하나씩 함수에 적용시키는 함수
- 리스트로 리턴할시 ```list()```사용
- ```map(함수, 리스트 or 튜플)```
- ```python
  # 일반함수
  def cal(x):
      return x * 2
  print(list(map(cal,[1,2,3])))	# [2, 4, 6]
  # 람다사용
  cal = lambda x: x * 2
  print(list(map(cal,[1,2,3])))	# [2, 4, 6]
  # 더 간단한 람다사용
  print(list(map((lambda x: x * 2), [1,2,3])))	# [2, 4, 6]
  ```

#### filter
- 리스트나 튜플의 원소들을 하나씩 함수로 ```Ture```값만 필터링하는 함수
- 리스트로 리턴할시 ```list()```사용
- ```filter(함수, 리스트 or 튜플)```
- ```python
  # 일반 함수
  def cal(x):
      return x%2 == 0
  print(list(filter(cal, range(5))))	# [0, 2, 4]
  # 람다 함수
  cal = lambda x:x%2 == 0
  print(list(filter(cal, range(5))))	# [0, 2, 4]
  # 더 간단한 람다 함수
  print(list(filter(lambda x:x%2 == 0, range(5)))) 	# [0, 2, 4]
  ```
#### reduce
- 시퀀스(문자열, 리스트, 튜플)의 원소들을 차례대로 함수에 적용시키는 함수
- ```python
  from functools import reduce 
  print(reduce(lambda x, y: x + y, [1, 2, 3]))	# 6출력, 1+2 -> 3+3->6
  print(reduce(lambda x, y: y + x, 'abc'))		# cba출력, b+a -> c+ba-> cba
  ```

## mypy
- 타입 힌트에 오류가 없는지 자동으로 체크
- 온라인일때만 가능
### 설치
- ```$ pip install mypy```
### 실행
- ```python
  c: str =1
  print(type(c))	#<class 'int'>출력
  $ mypy ex.py	# ex.py 해당파일명
  # ex.py:1: error: Incompatible types in assignment (expression has type "int", variable has type "str")
  # Found 1 error in 1 file (checked 1 source file)	출력
  ```
## 리스트 컴프리헨션(List Comprehension)
- 기존 리스트를 기반으로 새로운 리스트를 생성(리스트외에 딕셔너리, set 가능)
- ```map```, ```filter``` 보다 가독성이 좋음
- 가독성을 위해 표현식은 2개까지
- 역할별로 줄구분을하면 가독성 증가
- ```python
  # 리스트 컴프리헨션x
  a=[]
  for n in range(5+1):
      if n%2 == 1:
          a.append(n)
  print(a)	# [1, 3, 5]출력
  # 리스트 컴프리헨션 o
  a=[n for n in range(5+1) if n%2 == 1]
  print(a)	# [1, 3, 5]출력
  # 역할별로 줄구분으로 가독성 증가
  a=[
      n for n in range(5+1)
      if n%2 == 1		
  ]
  ```
  
## 제너레이터(Generator)
- iterator를 생성해주는 함수
- yield 구문을 통해, 실행중인 값을 리턴하지만 함수는 계속 동작
- 루프의 반복동작(iteration)을 제어
- ```python
  # Example
  def a():
      n=0
      while True:
          n+=1
          yield n
  b=a()		
  print(b)		#<class 'generator'>출력
  print(next(b))	#1출력
  print(next(b))	#2출력
  ```

### iter()
-  내장함수 iter()로 iterator 객체 생성
- iterator는 iterable한 객체를 내장함수 또는 iterable객체의 메소드로 객체를 생성
- iterable 객체 - 반복 가능한 객체( list, dict, set, str, bytes, tuple, range)
- iterator 객체 - 값을 차례대로 가져올 수 있는 객체
- iter(iterable) -> iterator iter(callable, sentinel) -> iterator
- Get an iterator from an object. In the first form, the argument must supply its own iterator, or be a sequence. In the second form, the callable is called until it returns the sentinel.
- ```python
  # Example
  a= iter([1, 2, 3])
  print(type(a))	# <class 'list_iterator'>출력
  print(next(a))	# 1출력
  print(next(a))	# 2출력
  print(next(a))	# 3출력
  ```

### 반복 가능한 객체(iterator)의 다음항목 리턴 - next()
- Return the next item from the iterator
- ```next(iterator[, default])```


## 구글 파이썬 가이드
### 가독성
- 함수의 기본값으로 가변 객체(Mutable Object)사용 금지 (불변객체(immutable Object)사용)
- ```python
  # Wrong:
  def a(b, c=[]):
      pass


  def a(b, c={}):
      pass
  # Correct
  def a(b, c=None):
      if c is None:
          c=[]
  ```
- bool 판별할 때 암시적(implicit)인 방법 사용
- 정수를 처리할때는 비교대상을 정수값으로 비교
- 세미콜론을 사용해 같은 줄에 두 문장x
- 최대 줄길이80
- ```python
  # Wrong:
  if len(users) == 0:
      pass
  if not i % 2:
      pass
  # Correct:
  if not users:
      pass
  if not i * 2 == 0:
      pass
  if  i % 2 == 0:
      pass
  ```

### 나눗셈 연산자 - ```//```
- 파이썬 2버전이하에서 ```/```와 같음
- int 결과 return
- ```python
  a= 5//3
  print(a)		#1출력
  print(type(a))	#<class 'int'>출력
  b= 5/3		
  print(b)		#1.6666666666666667출력
  print(type(b))	#<class 'float'>출력

### 몫과 나머지 동시 계산 - ```divmod()```
- Return the tuple (x//y, x%y). Invariant: div*y + mod == x
- 몫과 나머지를 튜플로 리턴
- ```python
  print(divmod(5,3)) # (1, 2)
  ```
### 모든 지역(local)변수 조회 - ```locals()```
- Return a dictionary containing the current scope's local variables
- ```python
  # 자동 줄바꿈으로 출력
  import pprint	
  a=1
  b=[2,3]
  class c():
      d=4
  pprint.pprint(locals())	
  # 'a': 1,
  # 'b': [2, 3],
  # 'c': <class '__main__.c'>,	d는 지역변수가 아니기때문에 출력x
  ```
### 예쁘게 출력 - ```pprint()```
- 복잡한 데이터를 깔끔하게 출력
- PrettyPrinter()
- Support to pretty-print lists, tuples, & dictionaries recursively.
- Very simple, but useful, especially in debugging data structures.
- ```python
  import pprint


  pprint.pprint({'a':1, 'b':2, 'c':'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa','d':'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'})
  """{'a': 1,
   'b': 2,
   'c': 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
   'd': 'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'} 출력
  """

  print({'a':1, 'b':2, 'c':'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa','d':'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'})
  """ {'a': 1, 'b': 2, 'c': 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', 'd': 'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'} 출력 """
  ```

### 빅오 표기법
- 입력값이 무한대로 향할때 함수의 상한을 설명하는 수학적 표기 방법
- 알고리즘의 효율성을 평가하기 위한 분석법 
- ```
  # 가진돈 10달러  
  1. 빅오 :100달러 미만 가지고 있어. 확실한 True 
  2. 빅세타: 4~7달러정도 가지고 있을걸?	False
  3. 빅오메가: 적어도 1달러는 있겠지. 애매하고 의미없는 True
  이와같이 세 표기법 중 상한선을 기준으로하는 빅오 표기법을 사용함
  사실상 빅오 표기법이 상한선을 정했어도 그 상한선이 최악의 경우가 아님
  ```
- 점근적 실행 시간을 표기하는 방법 (실행 시간은 최대한 이만큼 커지지만 더 천천히 커질 수도 있음을 의미)
- 점근적 실행 시간은 달리 말하면 시간 복잡도라 할 수 있고, 시간 복잡도는 어떤 알고리즘을 수행하는데 걸리는 시간을 설명하는 계산 복잡도를 의미
- 계산 복잡도를 표기하는 대표적 방법이 빅오 표기법
- 빅오로 시간복잡도를 표현할 때 최고차항만을 표기하고 계수는 무시 (ex. 입력값 n에 대한 계산 함수 3n^2+n+1에서 시간복잡도는 O(n^2))
- 빅오는 공간복잡도를 표현하는데에도 쓰임
- 대부분의 알고리즘은 시간과 공간이 트레이드오프관계(실행 시간이 빠른 알고리즘은 공간을 많이 사용, 공간을 적게 차지하는 알고리즘은 실행 시간이 느림)
#### 빅오 표기법 종류
1. ```O(1)``` - 입력값이 아무리 커도 실행시간 일정, 최고의 알고리즘이지만 상수값이 너무 크다면 일정한 시간의 의미가 사라짐(ex. 해쉬 테이블의 조회 및 삽입)
- ```python
   # Example
   def a(x):
      print('Hello', x)
      print('Hello', x)
   ```
- 오직 한 단계의 연산만 실행
2. ```O(log n)``` - 로그함수의 특징으로 인해 매우 큰 입력값에도 크게 영향을 받지 않음(ex. 이진 검색)
3. ```O(n)``` - 실행시간이 입력값에 비례하고, 이를 선형 시간알고리즘이라 부름(ex. 정렬되지 않은 리스트에서 최대값, 최소값을 찾는 경우)
4. ```O(n log n)``` - 병합 정렬과 같이 대부분의 효율 좋은 정렬 알고리즘이 이에 해당, 모든 수에 한 번 이상 비교해야 하는 비교 기반 정렬 알고리즘은 이 알고리즘보다 빠를 수 없음
5. ```O(n^2)``` - 비효율적인 정렬 알고리즘(ex. 버블 정렬)
6. ```O(2^n)``` - n^2보다 훨씬 비효율적인 알고리즘(ex.  피보나치 수를 재귀로 계산)
7. ```O(n!)``` - 가장 느린 알고리즘, 입력값이 조금만 커져도 계산이 힘듬(ex. 가장 짧은 경로를 찾는 외판원문제를 브루트 포스로 풀이할 때)

#### 상한과 최악의 경우
- 빅오(O)는 상한(Upper Bound), 빅오메가는 하한(Lower Bound), 빅세타는 평균
- 업계에서는 빅세타와 빅오를 하나로 합쳐 표현하는 경향이 있음
- 상한과 최악의 경우는 서로 다름
- 최악의 경우는 문제 크기에따라 정해지고, 상한은 함수가 가장 늦게 싱행될 때를 나타냄
- 빅오 표기법은 정확하게 쓰기에는 너무길고 복잡한 함수를 적당히 정확하게 표현하는 방법일뿐, 최악의 경우/평균적인 경우의 시간 복잡도와는 아무런 관계가 없음
- 빅오 표기법은 주어진(최선/최악/평균) 경우의 수행 시간의 상한을 나타냄     

### 분할 상환 분석(Amortized Analysis)
- 빅오와 함께 함수의 동작을 설명할 때 중요한 분석 방법 중 하나
- 특정 상황에서는 좋지 않은 성능을 내지만, 나머지 상황에서는 좋은 성능을 낼 때 모든 연산을 고려해 성능을 분석하는 것(평균)
- 최악의 경우를 여러 번에 걸쳐 골고루 나눠주는 형태로 알고리즘 시간 복잡도를 계산
- 동적배열이 대표적(메모리의 크기를 늘릴때는 많은시간이 발생하지만, 메모리의 크기를 늘린 후 메모리에 값을 넣는 시간은 거의 들지 않기 때문에 처음 많이 걸린 시간을 적게 걸린시간에 분산시키는 것)

#### 병렬화 
- 일부 알고리즘들은 병렬화를 통해 실행 속도를 높일 수 있음
- GPU는 병렬 연산의 대표적인 장치
- 병렬화가 가능여부에 따라 알고리즘의 우수성을 평가하는 중요한 척도
- 딥러닝이 대표적

#### 임의 정밀도
- 자리수가 정해져있지 않고 배열을 통해 무한한 자리수를 제공
- 파이썬은 임의 정밀도를 사용하는데, 임의 정밀도 정수형에서 정수를 숫자의 배열로 표현
- 실행 속도는 늦어지지만, 오버플로로 오류방지와 단일화된 형태덕분에 편리함

#### 매핑
- 매핑 타입은 키와 자료형으로 구성된 복합 자료형
- 파이썬에 내장된 것 중 딕셔너리가 유일

#### 집합 
- 중복된 값을 갖지 않은 자료형
- 파이썬에서는 ```set```이 집합 자료형
- ```python
  # 빈 집합 선언
  a = set()
  print(type(a))	# <class 'set'>출력
  ```
#### 시퀀스(Sequence)
- 수열의 의미로 어떤 특정 대상의 순서 있는 나열
- 파이썬에서는 문자열, 튜플, 바이트가 불변 시퀀스, 리스트가 가변 시퀀스

#### 객체
- 객체는 어떠한 상태```(속성(attributes) or 값(value))```와 동작```(behavior(methods))```을 가지고 있는 데이터
- 파이썬은 모든 것이 객체이고, 객체지향프로그래밍
- C언어는 원시 타입
- Java는 원시타입, 객체
- 원시 타입은 속도와 성능 중심이지만, 객체는 다양한 기능과 편의성 중심
- 파이썬의 과학 계산 모듈인 Numpy는 C로 만든 모듈이며 내부적으로 원시 타입으로 처리하여 매우 빠름
##### 불변 객체
- ```bool, int, float, tuple, str```
- ```python
  a = 1		# 숫자, 문자 모두 객체
  b = a
  print(id(1))	# 2902974071024, 파이썬의 모든 것이 객체이므로, 메모리 상에 위치한 객체의 주소를 가져오는 id()의 함수 값은 모두 동일
  print(id(a))	# 2902974071024
  print(id(b))	# 2902974071024
  ```

##### 가변 객체
- ```list, set, dict```
- ```python
  a = [1, 2]
  b = a
  a[1] = 3		# 리스트는 가변 객체이므로 a를 할당하는 b도 변경됨
  b[0] = 0
  print(a)		# [0, 3]	
  print(b)		# [0, 3]
  ```

##### 객체 지향 프로그래밍 특징 
1. 추상화
- 여러 객체의 공통적인 특징(속성이나 기능)을 도출
2. 캡슐화
- 구현되는 부분을 외부에 드러나지 않도록 정보를 은닉
- 데이터와 기능을 하나로 묶을 수 있음
3. 상속성
- 다른 클래스의 속성과 기능을 편리하게 사용할 수 있음(기존 코드 재활용)
4. 다형성
- 하나의 변수, 함수가 상황에 따라 다른 의미로 응답
- 오버라이딩, 오버로딩 가능
- 오버라이딩 - 부모클래스의 메서드를 재정의 
- 오버로딩 - 같은 이름의 메서드를 정의하고, 매개변수의 유형과 개수를 다르게하여 다양한 유형의 호출에 응답(파이썬에서는 정식으로 오버로딩 지원x, 구현은 가능)
- ```python
   class SampleA():
      def add(self, *a):	#매개변수를 여러개 받는것을 통해 비슷하게 구현가능
          b = 0
          for x in a:
              b+=x
          return b
        
        
   a = SampleA()
   print(a.add(1, 2, 3))		# 6출력
   ```
##### 객체 지향 프로그래밍 장점
- 코드 재사용 용이(만들어진 클래스를 사용하거나 상속이용)
- 실세계에 대한 쉬운 모델링(일상생활에서 사용하는 객체 개념을 그대로 표현가능)
- 유지 보수 쉬움(클래스 내부 수정만으로 전체적인 코드 수정 가능)
- 대형 프로젝트에 적합(클래스 단위로 모듈화가 가능하므로 업무 분담이 쉬움)
##### 객체 지향 프로그래밍 단점
- 성능, 속도 느림
- 용량 큼
- 설계시 많은 시간과 노력필요

#### is & ==
- ```is```는 ```id()```값을 비교하는 함수
- ```None```은 널```(null)```로서 값이 정의되어 있지 않기 때문에 ```==```로 비교 불가능
- ```pyhton
  a = [1, 2]
  print(id(a))	# 1968638416384	
  print(id(list(a)))	# 1968638526016, 새로운 리스트생성으로 id()값이 변경됨
  if a == list(a):
      print('True') 	# True
  else: 
      print('False')
  if a is list(a):	# id()값이 다름
      print('True')
  else: 
      print('False') 	# False	
  if a is a:
      print('True') 	# True
  else: 
      print('False')
  ```
### 문자열 처리 - 정규표현식
- 복잡한 문자열을 처리할 때 사용하는 기법으로, 파이썬만의 고유 문법이 아니라 문자열을 처리하는 모든 곳에서 사용
#### 메타 문자
- 본래 문자가 가진 의미가 아닌 특별한 용도로 사용하는 문자
- ```. ^ $ * + ? { } [ ] \ | ( )```
##### 문자 클래스 -  ```[ ]```
- ```[ ]``` 사이의 문자들과 매치
- ```[ ]``` 안의 두 문자 사이에 하이픈(-)은 범위
- ```python
  # Example
  [abc]  # a, b, c 중 한 개의 문자와 매치
  'def'	# 정규식과 매치되지 않음
  'abd'	# 정규식과 매치
  [a-c]	# [a-c] = [abc]
  [1-3]	# [1-3] = [123]
  [a-zA-Z] : 알파벳 전체
  [0-9] : 숫자 전체
  ```

##### 반대 - ``^``
- 문자 클래스```[ ]``` 안에 ```^``` 사용시 반대(not)
- ```python
  # Example
  [^a-zA-Z] # 문자 제외
  ```
#### 자주 사용하는 문자 클래스
- ```\d``` - 숫자 전체, ```[0-9]```
- ```\D``` - 숫자 제외, ```[^0-9]```
- ```\s``` - whitespace , ```[ \t\n\r\f\v]```
- ```\S``` - whitespace 제외, ```[^ \t\n\r\f\v]```
- ```\w``` - 문자+숫자, ```[a-zA-Z0-9]```
- ```\W``` - 문자+숫자 제외, ```[^a-zA-Z0-9]```

#### 모든 문자 - ```Dot(.)```
- 줄바꿈(\n) 문자를 제외한 모든 문자와 매치
- ```python
  # Example
  a.b	# "a+ 모든문자 + b", 정규식
  "a123dwhsb # 모든문자 .와 일치하므로 정규식과 매치
  "abc"	# a문자와 b문자 사이에 하나 이상의 문자가 존재하지 않아 매치되지 않음
  a[.]b # "a.b", 정규식
  a1b # 매치x
  ```
#### 반복 - ```*```
- ```*```앞 문자가 0부터 무한대로 반복(메모리 제한으로 2억개 정도까지)
- ```python
  # Example
  a*pple	# 정규식
  "pple"	# 'a' 가 0번 반복되었으니 매치
  "aaapple" # 'a'가 0번 이상 반복되어 매치
  ```

#### 반복 - ```+```
- ```+```앞 문자가 1부터 무한대로 반복(메모리 제한으로 2억개 정도까지)
- ```python
  # Example
  a+pple # 정규식
  "pple" # 'a'가 0번 반복되어 매치x
  ''aaaapple" # 'a'가 1번 이상 반복되어 매치
  ```
#### 반복 제한 - ```{m,n}, ?```
- ```{m, n}```앞 문자를 m부터 n까지 반복
- ```m``` 생략시 0, ```n``` 생략시 무한대
- ```?``` = ```{0, 1}```, 0~1반복
- ```python
  # Example
  a{2}pple # 정규식, 'a' 반드시 두번 반복
  "apple"	#  'a' 한번 반복 매치x
  "aapple"	#  'a' 두번 반복 매치
  a{2,}pple	# 정규식, 'a' 두 번 이상 반복
  "aaaapple"	# 'a' 두 번 이상 반복 매치
  a{,2}pple 		# 'a' 두 번 이하 반복 매치
  "pple"	# 'a' 0번 매치
  "aapple"	# 'a' 2번 매치 
  a{2,5}pple # 정규식, 'a' 2~5번 반복
  "apple"	# 'a' 1번 반복 매치x
  "aaapple"	# 'a' 3번 반복 매치
  a?pple # 정규식, 'a' 0~1번 반복
  "pple" # 매치
  "apple" # 매치
  ```
 
#### 파이썬 정규 표현식 지원 - re 모듈
- 파이썬에서 정규표현식을 지원하기 위해 re(regular expression)모듈을 제공
- re 모듈은 파이썬을 설치할 때 자동으로 설치되는 기본 라이브러리
- ```pyhton
  import re
  
  
  a = re.compile('abc*')	# 정규식 'abc*' 컴파일하여 패턴 객체 Return, Compile a regular expression pattern, returning a Pattern object
  ```
##### 정규식을 이용한 문자열 검색
- 컴파일된 패턴(정규식을 컴파일한 결과) 객체를 사용하여 문자열 검색
- 컴파일된 패턴 객체는 4가지 메서드 제공
##### Method
1. ```match()``` - 문자열의 처음부터 정규식과 매치되는지 조사(매치 되면 match 객체(정규식의 검색결과) retrun, 안될 시 None return)
2. ```search()``` - 문자열 전체를 검색하여 정규식과 매치되는지 조사(매치 되면 match(정규식의 검색결과) 객체 retrun, 안될 시 None return)
3. ```findall()``` - 정규식과 매치되는 모든 문자열을 리스트로 return
4. ```finditer()``` - 정규식과 매치되는 모든 문자열을 반복 가능한 객체로 return

###### match()
- ```python
  # Example
  import re
  a = re.compile('[a-z]+')
  t = a.match('hello')
  print(t)	# <re.Match object; span=(0, 5), match='hello'>, 정규식에 매치되므로 match 객체 return
  z = a.match('2hello')	# match는 문자열 처음부터 비교하므로 매치x
  print(z)	# None
  print(t.group())	# hello, 매치된 문자열 retrun
  ```

###### search()
- ```python
  # Example
  import re
  a = re.compile('[a-z]+')
  x = a.search('hello')
  print(x)	# <re.Match object; span=(0, 5), match='hello'>
  y = a.search('2hello')
  print(y)	# <re.Match object; span=(1, 6), match='hello'>, 문자열 전체를 검색하여 정규식과 매치되는지 조사하기 때문에 match 객체 return
  z = a.search('2he3llo')
  print(z)	# <re.Match object; span=(1, 3), match='he'>, 3에서 매치가 끝
  ```


###### findall()
- ```python
  # Example
  import re
  a = re.compile('[a-z]+')
  x = a.findall('hello')	# ['hello']
  print(x)
  y = a.findall(' h e l l o') # ['h', 'e', 'l', 'l', 'o'], 정규식과 매치되는 모든 문자열을 리스트로 return
  print(y)
  ```

###### finditer()
- ```python
  # Example
  import re
  a = re.compile('[a-z]+')
  x = a.finditer('hello')
  print(x)		# <callable_iterator object at 0x0000019A8E0FE9E0>, findall과 기능은 동일하지만 return시 반복가능한 객체(iterator object)로 return
  y = a.finditer(' hel lo')
  print(y)		# <callable_iterator object at 0x0000019A8E19EB90>
  for i in x:	
      print(i)	# <re.Match object; span=(0, 5), match='hello'>, 반복가능한 객체가 포함하는 각각의 요소는 match 객체
  for i in y:
      print(i)	# <re.Match object; span=(1, 4), match='hel'>
      # <re.Match object; span=(5, 7), match='lo'>
  ```
#### match 객체의 메서드
1. ```group()``` - 매치된 문자열 return
2. ```start()``` - 매치된 문자열의 시작 위치 return
3. ```end()``` - 매치된 문자열의 끝 위치를 return
4. ```span()``` - 매치된 문자열의 (시작, 끝)에 해당하는 튜플을 return
- ```python
  # Example
  import re
  
  
  a = re.compile('[a-z]+')
  x = a.match('hello')
  print(x)	# <re.Match object; span=(0, 5), match='hello'>
  print(x.group())	# hello
  print(x.start())	# 0, None이 아닐경우 match객체의 start() 값은 항상0
  print(x.end())	# 5
  print(x.span())	#(0, 5)
  ```

##### 컴파일 축약하기
- re 모듈은 compile을 축약할 수 있음
- 컴파일과 메서드를 한번에 실행 가능
- 한번 만든 패턴 객체를 여러번 사용할 때는 re.complie을 사용하는 것이 편함
- ```python
  # Example
  import re


  # 기본
  a = re.compile('[a-z]+')
  x = a.match('hello')
  # 코드 축약
  y = re.match('[a-z]+', 'hello')
  ```

##### 컴파일 옵션
1. DOTALL(S) - (.)을 줄바꿈 문자를 포함하여 모든 문자와 매치
2. IGNORECASE(I) - 대소문자에 관계없이 매치
3. MULTILINE(M) - 여러줄과 매치(^, $ 메타문자와 관계)
4. VERBOSE(X) - verbose 모드를 사용(정규식을 보기 편하게 하고, 주석 사용 가능)

##### DOTALL, S
- ```.``` 메타문자는 줄바꿈 문자(\n)를 제외한 모든 문자와 매치지만, ```re.DOTALL``` or ```re.S```을 사용하면 (\n)도 포함하여 매치
- 여러 줄로 이루어진 문자열에서 주로 사용
- ```python
  # DOTALL, S x
  import re
  
  
  a = re.compile('a.b')
  b = a.match('a\nb')
  print(b) # None, 줄바꿈 매치x
  # DOTALL, S o
  a = re.compile('a.b', re.DOTALL)
  b = a.match('a\nb')
  print(b)	# <re.Match object; span=(0, 3), match='a\nb'>, 줄바꿈 포함 매치o
  ```
 
##### IGNORECASE, I
- ```re.IGNORCASE``` or ```re.I``` 옵션은 대소문자 구별 없이 매치를 수행하는 옵션
- ```python
  # IGNORECASE, I x
  import re
  
  
  a = re.compile('[a-c]')	# 소문자만
  b = a.match('AA')
  print(b)	# None
  # IGNORECASE, I o
  a = re.compile('[a-c]', re.I)	# 소문자 + 대문자
  b = a.match('AA')
  print(b)	# <re.Match object; span=(0, 1), match='A'>
  ```
##### 메타 문자
##### or - (|)
- or과 동일한 의미로 사용
- ```python
  # Example
  import re
  
  
  a = re.compile('a|b')
  b = a.match('b')
  print(b)	# <re.Match object; span=(0, 1), match='b'>
  ```


##### 문자열 처음 - (^)
- 문자열 앞 (^)은 문자열의 처음은 항상 그 문자열로 시작해야 매치
- ```python
  # 매치o
  import re


  a = re.compile('^abc')
  b = a.match('abcdd')
  print(b)	# <re.Match object; span=(0, 3), match='abc'>
  # 매치x
  a = re.compile('^abc')
  b = a.match('abbbb')
  print(b)	# None
  ```
##### 문자열 끝 - ($)
- 문자열 끝의 ```$```은 문자열의 마지막은 항상 그 문자열로 끝나야 매치
- ``` python
  # Example
  import re
  
  
  a = re.compile('abc$')
  b = a.match('abc')
  print(b)	# <re.Match object; span=(0, 3), match='abc'>
  b = a.match('dabc')
  print(b)	# None
  b = a.match('abcd')
  print(b)	# None

##### 불변 문자열 처음 - ```\A```
- \A는 (^)처럼 전체 문자열의 처음과 매치되지만, re.MULTILINE 옵션을 사용하면 (^)은 각 줄의 문자열 처음과 매치되도록 변하지만, \A는 그대로 전체 문자열의 처음과 매치
- ```python
  # (^) Use
  import re
  
  
  a = re.compile('^abc\s\w+', re.M)
  b = a.findall("""abc de
  de abc
  abc de
  """)
  print(b)	# ['abc de', 'abc de']
  # (\A) Use
  import re
  a = re.compile('\Aabc\s\w+', re.M)
  b = a.findall("""abc de
  de abc
  abc de
  """)
  print(b)	# ['abc de']
  ```
##### 불변 문자열 끝 - ```\Z```
- ```\Z```는 ```($)```처럼 전체 문자열 끝과 매치되지만, re.MULTILINE 옵션을 사용하면 ($)은 각 줄의 끝에 매치되도록 변하지만, \Z는 그대로 전체 문자열 끝과 매치
- ```python
  # ($) Use
  import re
  
  
  a = re.compile('\w+\sabc$', re.M)
  b = a.findall("""de abc
  abc de
  de abc
  """)
  print(b)	# ['de abc', 'de abc']
  # (\Z) Use
  import re
  
  
  a = re.compile('\w+\sabc\Z', re.M)
  b = a.findall("""de abc
  abc de
  de abc""")
  print(b)	# ['de abc']
  ```
##### 단어 구분자 - ```\b```
- ```\b```는 파이썬 리터럴 규칙에 의해 백스페이스를 의미하지만, 메타 문자로 사용할 때 **Raw String**을 알려주는 기호```(r)``` 사용시 단어구분자 ,즉 ```whitespace```에 의해 구분됨
- ```python
  # Example
  import re
  
  
  a = re.compile(r'\babc\b', re.M)
  b = a.findall('abcabcd abc')
  print(b)	# ['abc']
  ```
##### etc 공백문자 - ```whitespace```
1. **space(띄어쓰기)**
2. **horizontal tab(수평 탭)**
4. **vertical tab(수직 탭)**
5. **newline(줄바꿈)**
- ```스페이스 바``` (space)(아스키코드 32)
- ```\b``` - 뒤로 한 칸 이동 (Backspace) (아스키코드 8)
- ```\t``` - 수평탭 간격 띄우기 (아스키코드 9)
- ```\n``` - 줄바꿈 (Linefeed) (아스키코드 10)
- ```\v``` - 수직탭 간격 띄우기 (아스키코드 11)
- ```\f``` - 프린트 출력 용지를 한 페이지 넘김 (Form feed) (아스키코드 12)
- ```\r``` - 동일한 줄의 맨 앞으로 커서 이동 (Carriage Return) (아스키코드 13)
- 또는 만우절에 에드윈 브래디, 크리스 모리스라는 두 사람이 발표한 모든 명령어가 스페이스, 탭, 엔터로 구성되어있는 난해한 프로그래밍 언어

##### 단어 구분자x - ```\B```
- ```\b```와 정반대로 단어가 whitespace로 구분되지 않을때 매치
- ```python
  # Match x
  import re
  
  
  a = re.compile(r'\Babc\B', re.M)
  b = a.findall('abc abc')
  print(b)	# [], whitespace은 물론, 문자열 시작과 끝도 구분되지않아야함
  # Match o
  import re
  
  
  a = re.compile(r'\Babc\B', re.M)
  b = a.findall('r abc r rabcr')
  print(b)	# ['abc'], 뒤 abc매치
  ```
##### MULTILINE, M
- ```re.MULTILINE``` or ```re.M``` 옵션은 메타문자 ```^```, ```$```을 문자열 전체의 처음과 끝이 아니라, 각 줄(라인)의 처음과 끝으로 매치(문자열이 여러줄일 때 사용)
- ```python
  # re.M 사용 x
  import re
  a = re.compile('^abc\s\w+')	# 문자열 + whitespace + 문자, 숫자 1개 이상 반복
  b = a.findall("""abc de
  de abc
  abc de
  """)
  print(b)	# ['abc de'], (^)메타문자 때문에 첫 줄만 매치
  # re.M 사용 o
  import re
  a = re.compile('^abc\s\w+', re.M)
  b = a.findall("""abc de
  de abc
  abc de
  """)
  print(b)	# ['abc de', 'abc de'], (^)를 문자열 전체의 처음이 아니라, 각 줄(라인)의 처음으로 매치
  ```

##### VERBOSE, X
- ```re.VERBOSE``` or ```re.X```옵션은 이해하기 어려운 정규식을 주석 또는 줄 단위로 구분
- 문자열에 사용된 ```whitespace```는 컴파일 때 제거([]안에 사용한 whitespace는 제외)
- ```python
  # VERBOSE 사용 x
  import re


  a = re.compile('^abc\w+[a-z]+[0-5]+[6-9]+', re.M)	#복잡함
  b = a.match('abcde09')
  print(b)	# <re.Match object; span=(0, 7), match='abcde09'>
  # VERBOSE 사용 o
  a = re.compile(""" 
  ^abc    # 문자열 시작 abc
  \w+     # 영어 + 숫자 1번 이상 반복
  [a-z]+  # a~z 1번 이상 반복
  [0-5]+  # 0~5 1번 이상 반복
  [6-9]+  # 6~9 1번 이상 반복
  """, re.X)
  b = a.match('abcde09')
  print(b) 	# <re.Match object; span=(0, 7), match='abcde09'>
  ```
