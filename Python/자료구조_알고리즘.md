# 파이썬
## PEP
- ```
  Python Enhancement Proposals
  ```
- 파이썬 개선 제안서
- 파이썬의 디자인 결정을 문서화한 파이썬의 주요 개발 프로세스
### PEP8 
- Style Guide for Python Code
- Python 코드에 대한 스타일 가이드
#### 들여쓰기
- 들여쓰기는 4개의 공백을 사용
- 첫번째 줄에 인자가 있으면 수직정렬
- 첫번째 줄에 인자가 없으면, 추가로 들여쓰기(4개)
- 추가적인 들여쓰기가 없어도 다음행과 구분이 되는경우 없어도 가능
- ```python
  # Correct:
  foo = long_function_name(var_one, var_two,
      var_three, var_four)		#수직정렬o
  def long_function_name(
        var_one, var_two, var_three,	#추가로 들여쓰기
        var_four):
    print(var_one)
  if (this_is_one_thing and
    that_is_another_thing):	#들여쓰기x
    do_something()		
  if (this_is_one_thing
        and that_is_another_thing):	#들여쓰기o
    do_something()
  # Wrong:
  foo = long_function_name(var_one, var_two,
    var_three, var_four)	#수직정렬x
  def long_function_name(
    var_one, var_two, var_three,
    var_four):	#추가 들여쓰기가 없어, 다음행과 구분이 안됨x
    print(var_one)
    ```
- 괄호위치는 마지막줄이나, 첫번째줄 둘다가능
- ```python
  # Correct:
    my_list = [	#마지막줄
        1, 2, 3,
        4, 5, 6,
        ]
    my_list = [	#첫번째 줄
        1, 2, 3,
        4, 5, 6,
    ]
   ```
#### 탭 or 스페이스
- 스페이스가 선호되는 들여쓰기 방식
- 탭과 스페이스를 혼합x
#### 최대 줄길이
- 모든 행은 최대 ```79```자로 제한
- 코드가 길어지는 경우 적절히 백슬래시```(\)```로 줄바꿈 가능(다음줄로 연결)
- ```python
    # Example
    with open('/path/to/some/file/you/want/to/read') as file_1, \
       open('/path/to/some/file/being/written', 'w') as file_2:
      file_2.write(file_1.read())
    ```
#### 이항 연산자 줄바꿈
- ```python
  # Wrong:
  # operators sit far away from their operands
  income = (gross_wages +	# 연산자가 뒤에있어 울퉁불퉁 보기 다소 불편함
            taxable_interest +
            (dividends - qualified_dividends) -
            ira_deduction -
            student_loan_interest)
  # Correct:
  # easy to match operators with operands
  income = (gross_wages
            + taxable_interest	# 이항연산자를 앞에 두는것이 직관적임
            + (dividends - qualified_dividends)
            - ira_deduction
            - student_loan_interest)
  ```
#### 빈줄
- 최상위 함수와 클래스 정의를 두 개의 빈줄로 둘러쌈
- 클래스 내의 메서드 정의는 한줄로 둘러쌈
- 관련된 그룹을 구분하기 위해 빈 줄을 추가하거나 생략가능
- ```python
  # Correct:
  def a():
      pass


  class b():

      def c():
          pass

      def d():
          pass


  class e():
      pass
  ```
#### Source File Encoding
- 파이썬의 배포판의 코드는 항상 ```UTF-8``` 을 사용
- 인코딩 선언이 없어야 함
#### Imports
- Import는 각각의 줄로 구분해야함
- import는 항상 파일의 맨위에 작성
- Wildcard```(*)``` imports는 가급적 사용자제
- ```python
  # Correct:
  import os
  import sys
  from subprocess import Popen, PIPE

  # Wrong:
  import sys, os
  from <module> import *	# (*)사용 자제
  ```


#### Module Level Dunder Names
- 두개의 언더바```(__)```가  앞뒤로있는 이름은 ```from __future__ imports``` 제외한 모든 imports 앞에 작성되어야함
- 파이썬은 docstring(주석)을 제외하고 다른코드 앞에 future-imports가 반드시 먼저 작성되어야함
- ```python
  """This is the example module.

  This module does stuff.	#docstring
  """
  from __future__ import barry_as_FLUFL

  __all__ = ['a', 'b', 'c']
  __version__ = '0.1'
  __author__ = 'Cardinal Biggles'

  import os
  import sys
  ```
  ####  문자열 따옴표
- '," 어느것을 사용해도 상관없음
- 이중 따옴표시에 서로 다른 따옴표 사용
- 세번따옴표시에 docstring PEP 257 규약대로 항상 큰 따옴표(")를 사용

#### 공백
- 괄호 바로안쪽에 공백 x
- ```python
  # Correct:
  spam(ham[1], {eggs: 2})
  # Wrong:
  spam( ham[ 1 ], { eggs: 2 } )
  - 콤마와 다음 괄호사이 공백x 
  # Correct:
  foo = (0,)
  # Wrong:
  bar = (0, )
  ```
- 콤마, 세미콜론, 콜론 바로 앞 공백x
- ```python
  # Correct:
  if x == 4: print x, y; x, y = y, x
  # Wrong:
  if x == 4 : print x , y ; x , y = y , x
  ```
- 슬라이스의 콜론에서 수식이나 함수가 들어갔을 때 동일한 공백 사용
- ```python
  # Correct:
  ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
  ham[lower:upper], ham[lower:upper:], ham[lower::step]
  ham[lower+offset : upper+offset]
  ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
  ham[lower + offset : upper + offset]
  # Wrong:
  ham[lower + offset:upper + offset]
  ham[1: 9], ham[1 :9], ham[1:9 :3]
  ham[lower : : upper]
  ham[ : upper]
  ```
- 함수 괄호옆 공백x
- ```python
  # Correct:
  spam(1)
  # Wrong:
  spam (1)
  ```
- 인덱싱, 슬라이싱 괄호 앞 공백x
- 함수 괄호옆 공백x
- ```python
  # Correct:
  dct['key'] = lst[index]
  # Wrong:
  dct ['key'] = lst [index]
  ```
- 연산자 주변에 둘 이상의 공백x
- 우선순위가 낮은 연산자 주변에만 공백o
- ```python
  # Correct:
  x = 1
  y = 2
  long_variable = 3
  # Wrong:
  x             = 1
  y             = 2
  long_variable = 3
  # Correct:
  i = i + 1
  submitted += 1
  x = x*2 - 1
  hypot2 = x*x + y*y
  c = (a+b) * (a-b)
  # Wrong:
  i=i+1
  submitted +=1
  x = x * 2 - 1
  hypot2 = x * x + y * y
  c = (a + b) * (a - b)
  ```
- 화살표 공백o
- ```python
  # Correct:
  def munge(input: AnyStr): ...
  def munge() -> PosInt: ...
  # Wrong:
  def munge(input:AnyStr): ...
  def munge()->PosInt: ...
  ```
- 주석없이 함수 매개변수의 기본값을 나타내는=사이 공백x
- 기본값에 대한 주석이 포함되어있으면 =사이 공백o
- ```python
  # Correct:
  def complex(real, imag=0.0):
      return magic(r=real, i=imag)
  # Wrong:
  def complex(real, imag = 0.0):
      return magic(r = real, i = imag)
  ```
- 같은 줄에 여러 문장x
- ```python
  # Correct:
  if foo == 'blah':
      do_blah_thing()
  do_one()
  do_two()
  do_three()
  # Wrong:
  if foo == 'blah': do_blah_thing()
  do_one(); do_two(); do_three()
  ```
- 때때로 if, for, while문을 적은 글자수로 한줄로 표현가능하면 권장은 하진않지만 작동은 가능
- ```python
  # Wrong:
  if foo == 'blah': do_blah_thing()
  for x in lst: total += x
  while t < 10: t = delay()
  # Wrong, Wrong:
  if foo == 'blah': do_blah_thing()
  else: do_non_blah_thing()

  try: something()
  finally: cleanup()

  do_one(); do_two(); do_three(long, argument,
                               list, like, this)

  if foo == 'blah': one(); two(); three()
  ```
#### 콤마 사용
- 후행에 콤마는 한 요소의 튜플을 만들때 필수라는 점을 제외하고 일반적으로 선택사항
- ```python
  # Correct:
  FILES = ('setup.cfg',)
  # Wrong:
  FILES = 'setup.cfg',
  ```
- 후행 콤마는 확장될 값에 유용하고, 종결괄호와 같은 줄에 사용x
- ```python
  # Correct:
  FILES = [
      'setup.cfg',
      'tox.ini',
      ]
  initialize(FILES,
             error=True,
             )
  # Wrong:
  FILES = ['setup.cfg', 'tox.ini',]
  initialize(FILES, error=True,)
  ```

#### 주석
- 코드와 모순되는 주석은 없는 것보다 안좋기 때문에 코드가 변경되면 주석을 항상 최신 상태를 유지
- 식별자가 아니라면 첫문자는 대문자(식별자의 대소문자 변경 금지)
- 블록 주석은 완전한 문장으로 구성된 하나 이상의 단락으로 구성되며, 각 문장은 마침표로 끝남
- 비영어권자만 읽는게 아니라면, 영어로 작성

##### Block 주석
- 블록 주석은 블록 주석 뒤에 오는 코드에 적용
- 코드와 같은 수준으로 들여쓰기
- 블록 주석 각 행은 #과 공백으로 시작
##### Inline 주석
- 인라인 주석은 적당히 사용
- 인라인 주석은 코드와 두 개 이상의 공백으로 구분
- #와 공백 하나로 시작
- 인라인 주석은 불필요하고, 당연한 것을 말할때 주의를 산만하게 함
- ```python
  # Wrong
  x = x + 1                 # Increment x
  # But sometimes, this is useful:
  x = x + 1                 # Compensate for border
  ```
##### Documentation Strings
- 모든 공용 모듈, 함수, 클래스 및 메서드에 대해서 작성
- 비공용 메서드에는 필요하지 않지만 메서드가 수행하는 작업설명에는 주석 작성
- 정의 라인 뒤에 표시되어야함 
- 1줄인 경우 """를 같은줄에 사용
- 1줄인 경우 함수/메서드의 매개변수를 반복 작성x
- ```python
  # Correct:
  def kos_root():
      """Return the pathname of the KOS root directory."""
      global _kos_root
      if _kos_root: return _kos_root
  # Wrong:
  def function(a, b):
      """function(a, b) -> list"""
  # Correct:
  def function(a, b):
      """Do X and return a list."""
  ```
- 2줄 이상인경우 각 인수를 별도의 행에 나열
- 2줄 이상 docstring(주석)에서는 후행의"""가 단독으로 사용
- ```python
  # Correct:
  def complex(real=0.0, imag=0.0):
      """Form a complex number.

      Keyword arguments:
      real -- the real part (default 0.0)
      imag -- the imaginary part (default 0.0)
      """
      if imag == 0.0 and real == 0.0:
          return complex_zero
      ...
  ```

#### 네이밍 컨벤션(Naming Convention) 
- 명명규칙
##### 스네이크 케이스(Snake Case)
- 파이썬에서 변수명과 함수명에서 사용하며, 각 단어를 밑줄 ```(_)```로 구분하여 표기하는 방식
클래스 이름- ```CapWords```
- 클래스이름은 각단어의 첫문자를 대문자로 표현
#### etc 
##### Java - 카멜 케이스(Camel Case)
- 카멜케이스는 낙타에서 유래되어 단어의 첫 단어의 시작은 소문자로 표기하고, 두번째 단어부터는 단어의 첫문자를 대문자로 표기하는 방식
##### 파스칼 케이스(Pascal Case)
- 카멜케이스와 비슷하지만 파스칼 케이스는 모든 단어의 첫문자를 대문자로 표기하는 방식 

## 타입 힌트(Type Hint)
- 파이썬은 대표적인 동적 타이핑언어이지만, 타입을 명시할 수 있는 타입 힌트가 존재
- 타입명시는 되지만, 강제로 지정하는게아니라 동적으로 작동될수 있어 주의가 필요
- 타입 명시가 안되있으면, 긴 코드에서 가독성이 떨어지고 에러발생 확률이 증가
- 변수는 변수 뒤에 콜론(:)을 붙이고 타입을 명시, 콜론 뒤에만 공백 한칸
- 함수의 리턴값에는 화살표(->) 사용, 화살표 양쪽으로 공백 한칸
- ```python
  a=1	# 타입지정x
  a: int=1	# 타입지정o
  def func(x: str) -> bool:	# 타입지정o
    pass
  c: str =1
  print(type(c))	# <class 'int'>출력
  ```

### typing 모듈
- typing 모듈로 조금더 구체적인 타입명시 가능

- ```python
  from typing import List, Set, Dict, Tuple
  num: List[int] = [1]
  unique_nums: Set[int] = {2, 3}
  Price: Dict[str, float] = {'a': 10, 'b': 50}
  Profile: Tuple[int, str, List[int]] = (25, "Byun", [177, 74])
  ```
#### 재할당이 불가능한 변수타입- Final
- ```python
  from typing import Final
  num: Final[int] = 10
  ```
#### 여러 타입- Union
- ```python
  from typing import Union
  
  
  def a(num: Union[int, float]) -> str:
      return str(num)
  a(1)  #'1'
  a(2.5)  #'2.5'
  ```
#### None을 사용하는 매개변수 - Optional
- ```python
  def a(b: str, num: Optional[int] = None) -> str:
      if num:
          return b * num
      else:
          return b
  ```
#### 함수의 매개변수와 리턴값 - Callable
- 함수의 매개변수와 리턴값을 명시
- 특히 함수를 매개변수로 받을때와 람다함수 사용시 주로 사용
- ```Callable[[매개변수 타입], 리턴 타입]```
- ```pyhton
  from typing import Callable


  def call(respon: Callable[[str], str], name: str) -> None:
      print(respon(name))
  respon: Callable[[str], str] = lambda name: name
  call(respon, "Byun")
  ```

#### 타입 추상화 - Iterable
- 함수의 매개변수의 타입을 명시할때 추상적으로 하는것이 좋은경우
- ```python
  from typing import Iterable


  def a(num: Iterable[int]) -> str:	# Iterable[int]로 인해, 제약없이 여러 데이터타입을 받을수있음
      return str(x) for x in num
  ```

#### 함수를 간단히 표현 - lambda
- 간단한 함수를 표현할때 사용
- ```lambda 매개변수: 표현식```
- ```python
  # 기본
  def cal(x):
      return print(x * 2)
  cal(2)
  # lambda 사용
  cal = lambda x:print(x * 2)
  cal(2)
  # 더 간단히 lambda 사용 (함수 이름 지정없이 호출을 한줄에)
  (lambda x:print(x * 2))(2)
  ```

#### map
- 리스트나 튜플의 원소들을 하나씩 함수에 적용시키는 함수
- 리스트로 리턴할시 ```list()```사용
- ```map(함수, 리스트 or 튜플)```
- ```python
  # 일반함수
  def cal(x):
      return x * 2
  print(list(map(cal,[1,2,3])))	# [2, 4, 6]
  # 람다사용
  cal = lambda x: x * 2
  print(list(map(cal,[1,2,3])))	# [2, 4, 6]
  # 더 간단한 람다사용
  print(list(map((lambda x: x * 2), [1,2,3])))	# [2, 4, 6]
  ```

#### filter
- 리스트나 튜플의 원소들을 하나씩 함수로 ```Ture```값만 필터링하는 함수
- 리스트로 리턴할시 ```list()```사용
- ```filter(함수, 리스트 or 튜플)```
- ```python
  # 일반 함수
  def cal(x):
      return x%2 == 0
  print(list(filter(cal, range(5))))	# [0, 2, 4]
  # 람다 함수
  cal = lambda x:x%2 == 0
  print(list(filter(cal, range(5))))	# [0, 2, 4]
  # 더 간단한 람다 함수
  print(list(filter(lambda x:x%2 == 0, range(5)))) 	# [0, 2, 4]
  ```
#### reduce
- 시퀀스(문자열, 리스트, 튜플)의 원소들을 차례대로 함수에 적용시키는 함수
- ```python
  from functools import reduce 
  print(reduce(lambda x, y: x + y, [1, 2, 3]))	# 6출력, 1+2 -> 3+3->6
  print(reduce(lambda x, y: y + x, 'abc'))		# cba출력, b+a -> c+ba-> cba
  ```

## mypy
- 타입 힌트에 오류가 없는지 자동으로 체크
- 온라인일때만 가능
### 설치
- ```$ pip install mypy```
### 실행
- ```python
  c: str =1
  print(type(c))	#<class 'int'>출력
  $ mypy ex.py	# ex.py 해당파일명
  # ex.py:1: error: Incompatible types in assignment (expression has type "int", variable has type "str")
  # Found 1 error in 1 file (checked 1 source file)	출력
  ```
## 리스트 컴프리헨션(List Comprehension)
- 기존 리스트를 기반으로 새로운 리스트를 생성(리스트외에 딕셔너리, set 가능)
- ```map```, ```filter``` 보다 가독성이 좋음
- 가독성을 위해 표현식은 2개까지
- 역할별로 줄구분을하면 가독성 증가
- ```python
  # 리스트 컴프리헨션x
  a=[]
  for n in range(5+1):
      if n%2 == 1:
          a.append(n)
  print(a)	# [1, 3, 5]출력
  # 리스트 컴프리헨션 o
  a=[n for n in range(5+1) if n%2 == 1]
  print(a)	# [1, 3, 5]출력
  # 역할별로 줄구분으로 가독성 증가
  a=[
      n for n in range(5+1)
      if n%2 == 1		
  ]
  ```
  
## 제너레이터(Generator)
- iterator를 생성해주는 함수
- yield 구문을 통해, 실행중인 값을 리턴하지만 함수는 계속 동작
- 루프의 반복동작(iteration)을 제어
- ```python
  # Example
  def a():
      n=0
      while True:
          n+=1
          yield n
  b=a()		
  print(b)		#<class 'generator'>출력
  print(next(b))	#1출력
  print(next(b))	#2출력
  ```

### iter()
-  내장함수 iter()로 iterator 객체 생성
- iterator는 iterable한 객체를 내장함수 또는 iterable객체의 메소드로 객체를 생성
- iterable 객체 - 반복 가능한 객체( list, dict, set, str, bytes, tuple, range)
- iterator 객체 - 값을 차례대로 가져올 수 있는 객체
- iter(iterable) -> iterator iter(callable, sentinel) -> iterator
- Get an iterator from an object. In the first form, the argument must supply its own iterator, or be a sequence. In the second form, the callable is called until it returns the sentinel.
- ```python
  # Example
  a= iter([1, 2, 3])
  print(type(a))	# <class 'list_iterator'>출력
  print(next(a))	# 1출력
  print(next(a))	# 2출력
  print(next(a))	# 3출력
  ```

### 반복 가능한 객체(iterator)의 다음항목 리턴 - next()
- Return the next item from the iterator
- ```next(iterator[, default])```


## 구글 파이썬 가이드
### 가독성
- 함수의 기본값으로 가변 객체(Mutable Object)사용 금지 (불변객체(immutable Object)사용)
- ```python
  # Wrong:
  def a(b, c=[]):
      pass


  def a(b, c={}):
      pass
  # Correct
  def a(b, c=None):
      if c is None:
          c=[]
  ```
- bool 판별할 때 암시적(implicit)인 방법 사용
- 정수를 처리할때는 비교대상을 정수값으로 비교
- 세미콜론을 사용해 같은 줄에 두 문장x
- 최대 줄길이80
- ```python
  # Wrong:
  if len(users) == 0:
      pass
  if not i % 2:
      pass
  # Correct:
  if not users:
      pass
  if not i * 2 == 0:
      pass
  if  i % 2 == 0:
      pass
  ```

### 나눗셈 연산자 - ```//```
- 파이썬 2버전이하에서 ```/```와 같음
- int 결과 return
- ```python
  a= 5//3
  print(a)		#1출력
  print(type(a))	#<class 'int'>출력
  b= 5/3		
  print(b)		#1.6666666666666667출력
  print(type(b))	#<class 'float'>출력

### 몫과 나머지 동시 계산 - ```divmod()```
- Return the tuple (x//y, x%y). Invariant: div*y + mod == x
- 몫과 나머지를 튜플로 리턴
- ```python
  print(divmod(5,3)) # (1, 2)
  ```
### 모든 지역(local)변수 조회 - ```locals()```
- Return a dictionary containing the current scope's local variables
- ```python
  # 자동 줄바꿈으로 출력
  import pprint	
  a=1
  b=[2,3]
  class c():
      d=4
  pprint.pprint(locals())	
  # 'a': 1,
  # 'b': [2, 3],
  # 'c': <class '__main__.c'>,	d는 지역변수가 아니기때문에 출력x
  ```
### 예쁘게 출력 - ```pprint()```
- 복잡한 데이터를 깔끔하게 출력
- PrettyPrinter()
- Support to pretty-print lists, tuples, & dictionaries recursively.
- Very simple, but useful, especially in debugging data structures.
- ```python
  import pprint


  pprint.pprint({'a':1, 'b':2, 'c':'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa','d':'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'})
  """{'a': 1,
   'b': 2,
   'c': 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
   'd': 'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'} 출력
  """

  print({'a':1, 'b':2, 'c':'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa','d':'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'})
  """ {'a': 1, 'b': 2, 'c': 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', 'd': 'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'} 출력 """
  ```

### 빅오 표기법
- 입력값이 무한대로 향할때 함수의 상한을 설명하는 수학적 표기 방법
- 알고리즘의 효율성을 평가하기 위한 분석법 
- ```
  # 가진돈 10달러  
  1. 빅오 :100달러 미만 가지고 있어. 확실한 True 
  2. 빅세타: 4~7달러정도 가지고 있을걸?	False
  3. 빅오메가: 적어도 1달러는 있겠지. 애매하고 의미없는 True
  이와같이 세 표기법 중 상한선을 기준으로하는 빅오 표기법을 사용함
  사실상 빅오 표기법이 상한선을 정했어도 그 상한선이 최악의 경우가 아님
  ```
- 점근적 실행 시간을 표기하는 방법 (실행 시간은 최대한 이만큼 커지지만 더 천천히 커질 수도 있음을 의미)
- 점근적 실행 시간은 달리 말하면 시간 복잡도라 할 수 있고, 시간 복잡도는 어떤 알고리즘을 수행하는데 걸리는 시간을 설명하는 계산 복잡도를 의미
- 계산 복잡도를 표기하는 대표적 방법이 빅오 표기법
- 빅오로 시간복잡도를 표현할 때 최고차항만을 표기하고 계수는 무시 (ex. 입력값 n에 대한 계산 함수 3n^2+n+1에서 시간복잡도는 O(n^2))
- 빅오는 공간복잡도를 표현하는데에도 쓰임
- 대부분의 알고리즘은 시간과 공간이 트레이드오프관계(실행 시간이 빠른 알고리즘은 공간을 많이 사용, 공간을 적게 차지하는 알고리즘은 실행 시간이 느림)
#### 빅오 표기법 종류
1. ```O(1)``` - 입력값이 아무리 커도 실행시간 일정, 최고의 알고리즘이지만 상수값이 너무 크다면 일정한 시간의 의미가 사라짐(ex. 해쉬 테이블의 조회 및 삽입)
- ```python
   # Example
   def a(x):
      print('Hello', x)
      print('Hello', x)
   ```
- 오직 한 단계의 연산만 실행
2. ```O(log n)``` - 로그함수의 특징으로 인해 매우 큰 입력값에도 크게 영향을 받지 않음(ex. 이진 검색)
3. ```O(n)``` - 실행시간이 입력값에 비례하고, 이를 선형 시간알고리즘이라 부름(ex. 정렬되지 않은 리스트에서 최대값, 최소값을 찾는 경우)
4. ```O(n log n)``` - 병합 정렬과 같이 대부분의 효율 좋은 정렬 알고리즘이 이에 해당, 모든 수에 한 번 이상 비교해야 하는 비교 기반 정렬 알고리즘은 이 알고리즘보다 빠를 수 없음
5. ```O(n^2)``` - 비효율적인 정렬 알고리즘(ex. 버블 정렬)
6. ```O(2^n) - n^2보다 훨씬 비효율적인 알고리즘(ex.  피보나치 수를 재귀로 계산)
7. ```O(n!)``` - 가장 느린 알고리즘, 입력값이 조금만 커져도 계산이 힘듬(ex. 가장 짧은 경로를 찾는 외판원문제를 브루트 포스로 풀이할 때)

#### 상한과 최악의 경우
- 빅오(O)는 상한(Upper Bound), 빅오메가는 하한(Lower Bound), 빅세타는 평균
- 업계에서는 빅세타와 빅오를 하나로 합쳐 표현하는 경향이 있음
- 상한과 최악의 경우는 서로 다름
- 최악의 경우는 문제 크기에따라 정해지고, 상한은 함수가 가장 늦게 싱행될 때를 나타냄
- 빅오 표기법은 정확하게 쓰기에는 너무길고 복잡한 함수를 적당히 정확하게 표현하는 방법일뿐, 최악의 경우/평균적인 경우의 시간 복잡도와는 아무런 관계가 없음
- 빅오 표기법은 주어진(최선/최악/평균) 경우의 수행 시간의 상한을 나타냄     

### 분할 상환 분석(Amortized Analysis)
- 빅오와 함께 함수의 동작을 설명할 때 중요한 분석 방법 중 하나
- 특정 상황에서는 좋지 않은 성능을 내지만, 나머지 상황에서는 좋은 성능을 낼 때 모든 연산을 고려해 성능을 분석하는 것(평균)
- 최악의 경우를 여러 번에 걸쳐 골고루 나눠주는 형태로 알고리즘 시간 복잡도를 계산
- 동적배열이 대표적(메모리의 크기를 늘릴때는 많은시간이 발생하지만, 메모리의 크기를 늘린 후 메모리에 값을 넣는 시간은 거의 들지 않기 때문에 처음 많이 걸린 시간을 적게 걸린시간에 분산시키는 것)

#### 병렬화 
- 일부 알고리즘들은 병렬화를 통해 실행 속도를 높일 수 있음
- GPU는 병렬 연산의 대표적인 장치
- 병렬화가 가능여부에 따라 알고리즘의 우수성을 평가하는 중요한 척도
- 딥러닝이 대표적

#### 임의 정밀도
- 자리수가 정해져있지 않고 배열을 통해 무한한 자리수를 제공
- 파이썬은 임의 정밀도를 사용하는데, 임의 정밀도 정수형에서 정수를 숫자의 배열로 표현
- 실행 속도는 늦어지지만, 오버플로로 오류방지와 단일화된 형태덕분에 편리함

#### 매핑
- 매핑 타입은 키와 자료형으로 구성된 복합 자료형
- 파이썬에 내장된 것 중 딕셔너리가 유일

#### 집합 
- 중복된 값을 갖지 않은 자료형
- 파이썬에서는 ```set```이 집합 자료형
- ```python
  # 빈 집합 선언
  a = set()
  print(type(a))	# <class 'set'>출력
  ```
#### 시퀀스(Sequence)
- 수열의 의미로 어떤 특정 대상의 순서 있는 나열
- 파이썬에서는 문자열, 튜플, 바이트가 불변 시퀀스, 리스트가 가변 시퀀스

#### 객체
- 객체는 어떠한 상태```(속성(attributes) or 값(value))```와 동작```(behavior(methods))```을 가지고 있는 데이터
- 파이썬은 모든 것이 객체이고, 객체지향프로그래밍
- C언어는 원시 타입
- Java는 원시타입, 객체
- 원시 타입은 속도와 성능 중심이지만, 객체는 다양한 기능과 편의성 중심
- 파이썬의 과학 계산 모듈인 Numpy는 C로 만든 모듈이며 내부적으로 원시 타입으로 처리하여 매우 빠름
##### 불변 객체
- ```bool, int, float, tuple, str```
- ```python
  a = 1		# 숫자, 문자 모두 객체
  b = a
  print(id(1))	# 2902974071024, 파이썬의 모든 것이 객체이므로, 메모리 상에 위치한 객체의 주소를 가져오는 id()의 함수 값은 모두 동일
  print(id(a))	# 2902974071024
  print(id(b))	# 2902974071024
  ```

##### 가변 객체
- ```list, set, dict```
- ```python
  a = [1, 2]
  b = a
  a[1] = 3		# 리스트는 가변 객체이므로 a를 할당하는 b도 변경됨
  b[0] = 0
  print(a)		# [0, 3]	
  print(b)		# [0, 3]
  ```

##### 객체 지향 프로그래밍 특징 
1. 추상화
- 여러 객체의 공통적인 특징(속성이나 기능)을 도출
2. 캡슐화
- 구현되는 부분을 외부에 드러나지 않도록 정보를 은닉
- 데이터와 기능을 하나로 묶을 수 있음
3. 상속성
- 다른 클래스의 속성과 기능을 편리하게 사용할 수 있음(기존 코드 재활용)
4. 다형성
- 하나의 변수, 함수가 상황에 따라 다른 의미로 응답
- 오버라이딩, 오버로딩 가능
- 오버라이딩 - 부모클래스의 메서드를 재정의 
- 오버로딩 - 같은 이름의 메서드를 정의하고, 매개변수의 유형과 개수를 다르게하여 다양한 유형의 호출에 응답(파이썬에서는 정식으로 오버로딩 지원x, 구현은 가능)
- ```python
 class SampleA():
    def add(self, *a):	#매개변수를 여러개 받는것을 통해 비슷하게 구현가능
        b = 0
        for x in a:
            b+=x
        return b
        
        
  a = SampleA()
  print(a.add(1, 2, 3))		# 6출력
  ```
