1) 깃허브 사용 & 깃 허브 액션 사용(테스트 자동화): 형상관리 시스템을 이용하여, 깃허브 액션으로 테스트를 자동화 시키는 환경을 조성
- 이를 통해, 코드의 안정성을 확보할수있고, 개발자가 테스트를 수작업으로 매번 만들거나 품질에 대한 테스트 실행을 요청하거나 일정을 잡는 대신, 테스트를 자동화하면, 
개발자가 독립적으로 코드를 개발하고 자동화테스트를 사용하면 문제를 즉각적으로 발견하고 해결할수 있게 된다.
실제로 gitaction과 같은 것을 이용해 변경사항이 push될때마다 프로덕션과 유사한 환경에서 자동 테스트가 신속하게 실행된다
이로써 해당 코드와 환경이 의도한 대로 동작하고 항상 안전하고 배포 가능한 상태에 있다는 점이 지속적으로 보장된다.
더불어 이러한 자동화 테스트를 통해서 각 개발자들이 빠르고 독립적으로 좋은 품질의 코드를 보유할수 있게 되고, 이로써 코드의 지속적인 통합과 배포를 할수 있는 환경도 조성된다.
- 이로 인해 지속적인 통합이 가능함 =>(브랜치에서 독립적으로 작업하는 기간이 길어질수록 트렁크로 통합하고 병합하는것은 더어려워진다)

2) 배포 자동화- 수작업이 많이 필요한 배포는, 수작업으로 인한 오류도 많이 생기기때문에, 자동화가 필수적으로 요구됨
그러므로 테스트 자동화를 기반으로 안정성이 구축된 환경에서 쉽게 배포 자동화를 만들 수 있음
- 이로 인해 지속적인 배포가 가능함 =>(통합과 마찬가지로, 배포또한 배포주기가 길어지면, 배포해야할 코드와 프로덕션에서 실행되는 코드 차이가 점차 누적되고 배포 작업의 크기가 커지게 된다)

3) 빠른 피드백 루프를 형성하기
일반적으로 빠르고 지속적인 피드백 루프가 존재하지 않는 복잡한 시스템에서는 대규모 프로덕션 중단이나 고객 데이터 유출과 같은 커다란 실패가 발생하는 경우 문제를 발견하게 된다.
하지만 프로세스의 모든단계에서 좌측에서 우측으로 빠르고 지속적인 전달(통합, 배포,전달)을 기반으로 우측에서 
좌측으로 빠르고 지속적인 피드백 루프를 생성하면, 모든 사람이 자신의 행동으로 인한 결과를 바로 확인할 수 있게되고, 
모든 종류의 문제가 더 작고, 적은 비용으로 쉽게 수정할 수 있을때 발견되고 해결할수 있게된다. 즉 치명적인 오류가 발생하기 
훨씬 전에 문제를 발견하고 해결해 안전한 시스템을 구축할 수 있게된다. 
또한 문제를 수정할때마다 조직학습을 통해 문제의 재발을 방지할 수 있고, 향후 이와 유사한 문제를 빠르게 감지하고 수정할수도 있다.


4)텔레메트리 사용
텔레메트리를 사용하면 문제를 더 빠르게 감지하고 수정할 수 있다. 
조직의 그 어떤 사람도 복잡한 전체시스템이 어떻게 연결되고, 
어떻게 동작되고있는지 전부다 이해할수없다. 그렇기때문에  프로덕션에서의 
예상치못한 시스템 중단 사태나 다양한 문제가 발생할수 있고, 문제를 해결하는데 필요한 정보조차 없는 경우가 많다. 
따라서, 문제가 발생할때마다 조직의 어느 누구도 확인할 수 있도록, 전체 시스템의 모든요소를 분석할 수 있는 
텔레메트리를 생성해 조직 전체 누구나 텔레메트리를 사용할수 있도록 해야한다. 텔레메트리를 이용하면 
문제의 원인이 무엇인지, 문제를 해결하는데 필요한게 무엇인지에 대한 과학적인 접근 방법을 사용할수 있게된다. 
이러한 텔레메트리를 통해 문제를 빠르게 발견하고 빠르게 해결할수 있을뿐만아니라, 문제가 발생하기도 전에 그 문제의 원인을 찾아 제거할수 있다. 
즉, 고객이 문제를 인지하기 훨씬 이전에 문제를 처리할수있게 된다. 이를 통해 고객의 만족도를 높일 수 있고 문제가 발생했을때 처리해야 하는 문제의 양과 위험을 감소시킬 수 있다.

5). 스워밍(데브옵스팀에서 문제 발생시)
그러나 단순히 문제를 빠르게 발견하는 것 만으로는 충분하지 않다. 
문제가 발생하면 스워밍기법을 통해, 모든 작업을 멈추어서라도 문제를 집중적으로 해결해야 한다. 문제를 발견했을때 회피하며 일하거나, 나중에 시간이 날때 문제 해결을 위한 일정을 잡지말고 
문제를 그 즉시 해결하기위해 스워밍 해야한다. 
왜냐하면, 이러한 문제들이 해결되지 않은채로 고객에게 전달될수도 있고, 이러한 문제들이 누적되어 결국 나중에 문제를 해결하고자 했을때,
더 많은 노력과 더 많은 비용으로 문제를 해결해야할수 있기 때문이다. 
또한 스워밍을 함으로써, 새로운 작업이 시작되는것을 방지할 수 있는데, 이는 새로운 작업으로 인해서 
또 새로운 문제가 발생될 수 있는 점을 차단해줄수 있고, 동일한 작업을 진행시 동일한 문제가 발생하여 더 많은 수정작업이 필요하게 되는 것을 차단해줄수 있다. 
문제를 회피하고 지나간다면, 시간이 지날수록 그 문제가 발생했을때 당시 상황을 정확하게 재구현하기 어렵기 때문에, 
더 많은 시간과 노력이 들게되고 원인에 대한 결과가 모호해지기 때문에 그 문제의 학습 또한 어려워진다.
그러나 문제발생시 문제가 해결될때까지 새로운 작업을 금지하고 스워밍을 하면, 작은 문제들이 악화되지 않고 신속하게  해결할수있게되고, 
그로인해 가치흐름내 모든 사람들에게 빠른피드백을 제공하여 조직전체가 학습이 가능케하며, 추후 원인과 결과를 불분명하게 만들수 있는 요인들을 제거할수 있게된다.
더불어, 문제 발생시 해결될때까지 스워밍을 하게 되므로, 이러한 환경속에서 지속적인 통합과 배포도 가능하게된다.