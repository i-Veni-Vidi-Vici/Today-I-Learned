출처:https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8
(인프런 스프링 핵심 원리 강의, 김영한)

##### orm
- 자바객체를 db에 편하게 저장하고 꺼내는 기술, 쿼리사용안함

## 스프링 부트
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성하며, Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버 설치가 필요없음
- 손쉬운 빌드 구성을 위한 starter 종속성 제공
  - 라이브러리를 묶어서 가져와야하는 것들을 starter가 편리하게 제공
- 스프링과 3rd parth(외부) 라이브러리 자동구성
  - 스프링 버전에 따른 지원하는 주요 외부라이브러리를 버전을 고려할 필요가 없음

- 메트릭, 상태확인, 외부 구성 같은 프로덕션 준비 기능 제공
  - 모니터링 기능 편리하게 제공
- 관례에 의한 간결한 설정
  - 대부분 디폴트로 설정되어있어, 수정이 거의 필요 없음

# 스프링 단어?
- 스프링이라는 단어는 문맥에 따라 다름
- 스프림 DI 컨테이너 기술
- 스프링 프레임워크
- 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계

### 스프링 왜 만들었을까?
스프링의 핵심
- 스프림은 자바 언어 기반의 프레임워크
- 자바언어의 가장 큰 특징이 객체 지향언어이고, 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
- 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크

### 객체 지향 특징
- 추상화
- 캡슐화
- 상속
- 다형성

### 객체 지향 프로그래밍
- 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러개의독립된 단위, 즉 객체들의 모임으로 파악하고자 하는 것
- 각 객체는 메시지를 주고받고, 데이터를 처리
- 프로그램을 유연하고 변경이 용이하게 만들어 대규모 소프트웨어 개발에 많이 사용


# 다형성
예
- 운전자 - 자동차(테슬라, 벤츠, k9)
- 공연 무대 로미오(원빈, 강동원) -줄리엣(송혜교, 김태희)
- 키보드, 마우스, 세상의 표준 인터페이스들
- 할인 정책 로직 
- 정렬 알고리즘

## 역할과 구현을 분리
- 역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경도 편리
장점
- 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
- 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.
- 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 안흔다.
- 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.

### 자바 언어
- 자바 언어의 다형성을 활용
- 역할= 인터페이스, 구현= 인터페이스를 구현한 클래스, 구현 객체
- 객체를 설계할 때 역할과 구현을 명확히 분리
- 객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기 -역할이 훨씬 중요

### 자바 언어의 다형성
- 오버라이딩은 자바 기본 문법
- 오버라이딩 된 메서드가 실행
- 다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경할 수 있음
- 클래스 상속관계도 다형성, 오버라이딩 적용 가능

#### 다형성의 본질
- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경가능
- 다형성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야함
- 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있음
- ex) 클라이언트(운전자)-> 구현체1(아반떼), 구현체2(테슬라)
## 객체의 협력이라는 관계부터 생각
- 혼자 있는 객체는 없다
- 클라이언트: 요청, 서버: 응답
- 수 많은 객체 클라이언트와 객체 서버는 협력 관계를 가짐
정리
- 실세계의 역할과 구현이라는 편히한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있음
- 유연하고 변경이 용이
- 확장 가능한 설계 
- 클라이언트에 영향을 주지 않는 변경 가능
- 인터페이스를 안정적으로 잘 설계하는 것이 중요 - 변경이 일어나지 않도록
한계
- 역할(인터페이스) 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 발생
- 자동차를 비행기로 변경시, 대본자체가 변경시, USB 인터페이스가 변경시

## 스프링과 객체 지향
- 다형성이 가장 중요
- 스프링은 다형성을 극대화해서 이용할 수 있게 도와줌
- 스프링에서 이야기하는 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원
- 스프링을 사용하면 마치 레고 블럭 조립하듯이, 공연 무대의 배우를 선택하듯이, 구현을 편리하게 변경할 수 있음

### 좋은 객체 지향 설계의 5가지 원칙(SOLID)
- 클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리
##### SRP 단일 책임원칙(single responsibility principle)
- 한 클래스는 하나의 책임만 가져야 한다
- 하나의 책임이라는 것은 모호하며, 클 수 있고 작을 수 도 있고, 문맥과 상황에 따라 다름
- 중요한 기준은 변경이다, 변경이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따른 것
ex) UI 변경, 객체의 생성과 사용을 분리

##### OCP 개방-폐쇄 원칙(Open/cloesd princiole)
- 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀 있어야 한다.
- 다형성을 활용
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현(기존 코드에 대한 변경이 필요 없음)
###### 문제점
- 클라이언트가 구현 클래스를 직접 선택
- ```java
	car c = new 아반떼(); //기존
	car c = new 테슬라(); // 변경
	```
- > 구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다.
- 분명 다형성을 사용했지만, OCP 원칙을 지킬 수 없다.
-> 문제 해결하기 위해서는 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요 -> 스프링의 역할

##### LSP 리스코프 치환 원칙 (Liskov substitution principle)
- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀수 있어야 함
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요
- 단순히 컴파일 성공을 넘어서는 이야기
ex) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리더라도 앞으로 가야함

##### ISP 인터페이스 분리 원칙(Interface segregation principle)
- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
- 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
- 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
- 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
- 인터페이스가 명확해지고, 대체 가능성이 높아짐

##### DIP 의존관계 역전 웍칙 (Dependency inversion principle)
- 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다" 의존성 주입은 이 원칙을 따르는 방법 중 하나이다.
- 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 것
- 역할에 의존하게 해야하지, 구현에 의존하게 해서는 안된다. 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다. 구현체에 의존하게 되면 변경이 아주 어려워짐
- 그러나 운전자는 car 인터페이스에 의존하지만, 구현클래스인 아반떼도 동시에 의존함
- 클라이언트(운전자)가 구현 클래스를 직접 선택하고 있음
- car c = new 아반떼();
-> DIP위반, 코드변경이 필요하는 문제가 생김

###### 정리
- 객체 지향의 핵심은 다형성
- 다형성만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.
- 다형성만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경됨
- 다형성만으로는 OCP,DIP를 지킬 수 없음
-> 뭔가 더 필요함


# 객체 지향 설계와 스프링
-스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원
	- DI(Dependency Injection)- 의존관계, 의존성 주입
	- DI 컨테이너 제공
		- 자바 객체들을 컨테이너 안에 넣어놓고, 의존관계를 서로 연결하고 주입해주는 기능을 제공
- 클라이언트 코드의 변경없이 기능 확장
- 쉽게 부품을 교체하듯이 개발

## 스프링이 없던 시절
- 옛날 어떤 개발자가 좋은 객체 지향 개발을 하려고 OCP, DIP 원칙을 지키면서 개발을 해보니, 너무 할일이 많고 배보다 배꼽이 더 컸다. 그래서 프레임워크로 만듦
- 순수하게 자바로 OCP , DIP원칙들을 지키면서 개발을 해보면, 결국 스프링 프레임 워크를 만들게 됨
- DI개념은 말보다는 코드로 짜봐야 필요성을 알게됨

###### 정리
- 모든 설계에 역할과 구현을 분리하자
- 자동차, 공연 예를 떠올려보자
- 애플리케이션 설계도 공연을 설계 하듯이 배역만 만들어두고, 배우는 언제든지 유연하게 변경할 수 있도록 만드는 것이 좋은 객체 지향 설계임
- 이상적으로는 모든설계에 인터페이스를 부여하자

###### 실무적인 고민
- 인터페이스를 도입하면 추상화라는 비용이 발생
	- 코드가 추상화됨으로써 오는 단점들이 존재, 장점이 단점을 넘어설때 사용해야함,ex) 인터페이스코드에서 다시한번 구현코드를 열어야하는 등
- 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법이다.
- 미래에 확장 가능성이 있으면 인터페이스사용

----------------------------------------------------------------------------------------------------------
##### TIP
###### IntelliJ의 Gradle 대신에 자바 직접 실행
- 최근 IntelliJ 버전은 Gradle을 통해서 실행 하는 것이 디폴트
- gradle보다 Intellij로 바꾸면, 자바로 바로 실행해서 실행속도가 더 빠름
- setting-> gradle 검색 -> 
Build and run using: IntelliJ IDEA
Run tests using: IntelliJ IDEA
로 변경

# 회원 도메인 설계

### 회원 도메인 협력 관계
- 기획자들도 볼 수 있음

### 회원 클래스 다이어그램 -정적
- 개발자가 구체화해서 클래스 다이어그램을 만듦
- 인터페이스와 구현체들이 다 모임
- 실제 서버를 실행하지 않고, 클래스만 분석해서 볼 수 있음

### 회원 객체 다이어그램 - 동적
- 서버가 실행될때, 동적으로 결정되는 리포지토리들때문에, 클래스 다이어그램만으로는 확인이 어려움
- 서버가 실제 사용하는 참조관계

##### TIP
- 실무에서 동시성 문제로 ```HashMap()```대신 ```ConCurrentHashMAp()```사용
- 구현체가 하나일경우 관례상 구현체 뒤에 ```Impl```붙임

----------------------------------------------------------------------------------------------------------
`ctrl + e // recent files`

## 제어의 역전 IoC(Inversion of Control)
- 기존 프로그램에서는 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성 연결하며 실행함
- 즉, 구현 객체가 프로그램의 제어 흐름을 컨트롤함
- 개발자 입장에서도 자연스러운 흐름
- 그러나 제어의 역전이 적용되면, 구현 객체는 자신의 로직을 실행하는 역할만 담당
- 프로그램의 제어 흐름은 구현 객체가 아닌 다른 곳에서 담당
- 따라서 구현객체는 사용될지 안될지 모른채, 자기 로직만 실행하며, 프로그램 제어 흐름은 외부에서 관리
- 이렇게 프로그램의 제어 흐름을 직접 제어하는 것이 아니라, 외부에서 관리하는 것을 제어의 역전(IoC)라고 함

#### 프레임워크 vs 라이브러리
- 프레임워크는 내가 작성한 코드를 제어하고, 실행함 (JUnit)
- 라이브러리는 내가 작성한 코드가 직접 제어의 흐름을 담당하는 것을 말함

### 의존관계 주입 DI(Dependency Ingection)
- 구현 객체는 인터페이스에 의존하며, 그 구현 객체 내에서 또 어떤 구현 객체가 사용될지는 모름
- 의존관계는 정적인 클래스 의존 관계와 실행 시점에 결정되는 동적인 객체(인스턴스) 의존관계 둘을 분리해서 생각 해야 함

##### 정적인 클래스 의존 관계
- 클래스가 사용하는 import 코드만 보고도 의존관계를 쉽게 판단 가능
- 정적인 의존관계는 애플리케이션을 실행하지 않아도 분석할 수 있음(클래스 다이어 그램)
- 그러나 이러한 정적 클래스 의존관계만으로는 실제 어떤 객체가 주입될지 알 수 없다.

##### 동적인 객체 인스턴스 의존관계
- 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계(객체 다이어 그램)
- 애플리케이션 실행 시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것을 의존관계 주입이라 함
- 객체 인스턴스를 생성하고, 그 참조값을 전달하여 연결됨
- DI 사용시, 클라이언트 코드를 변경하지 않고도 클라이언트가 호출하는 대상의 타입 인스턴스를 변경가능
- DI 사용시, 정적인 클래스 의존관계를 전혀 변경시키지 않고, 동적인 객체 인스턴스 의존관계만 쉽게 변경하면 됨

### IoC 컨테이너, DI 컨테이너
- 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 Ioc컨테이너 또는 DI컨테이너라고 함
- 의존관계 주입에 초점을 맞춰 주로 DI 컨테이너라고 함(스프링이 DI 컨테이너로 불림)
- 애플리케이션 전체를 조립한다는 의미에서 어셈블러, 오브젝트 팩토리 등으로 불리기도 함

# 스프링 컨테이너
- 기존에는 개발자가 직접 객체를 생성하고 DI를 했지만, 스프링 컨테이너를 통해서 사용할 수 있음

### @Configuration
- 스프링 컨테이너는 ```@Configuration```붙어있는 것을 설정정보로 사용함
- ```java
	@Configuration AppConfig(){}
	```
### @Bean
- 설정정보의 메소드에 각각 적어줌
- ```@Bean```이 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록함
- 이렇게 스프링 컨테이너에 등록된 객체를 스프링 빈이라 함
- 스프링 빈은 ```@Bean```이 붙은 메서드의 명을 스프링 빈의 이름으로 사용
- 이름 변경 가능 ```@Bean(name = "new")```
- ```java
	@Bean
	    public MemberService memberService(){}
   	```

### ApplicationContext
- 스프링 컨테이너
- 스프링은 항상 ```ApplicationContext```으로 시작
- ```@Bean``` 메서드를 다 관리해줌
- 이전에는 개발자가 필요한 객체를 직접 조회했지만, 이제는 스프링 컨테이너를 통해 필요한 스프링 빈(객체)를 찾아야 함
- 스프링 빈은 ```applicationContext.getBean()``` 메서드를 사용해 찾을 수 있음
- 기존에 개발자가 직접 자바코드로 모든 것을 했지만, 스프링 컨테이너를 이용하면 객체를 스프링 빈으로 등록하고, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경됨
- ```java
 	ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
	//AppConfig에 있는 @Bean 메서드를 컨테이너에 객체 생성, 관리를함
	MemberService memberService = applicationContext.getBean("Bean 에 등록된 메서드 이름", 타입);
 	```



스프링 컨테이너 장점
