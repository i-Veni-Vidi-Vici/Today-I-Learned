자료구조
- 컴퓨터의 메모리 자원은 매우 한정적인데 반해 처리해야 할 데이터는 무수히 많을 수 있다
- 메모리 공간을 효율적으로 사용해야 하는데 이때 필요한 것이 자료 구조
- 모든 목적에 맞는 자료구조는 없다
- 따라서 각 자료구조가 갖는 장점과 한계를 잘 아는 것이 중요


알고리즘
- 어떤 문제를 해결하기 위해 정해진 일련의 절차나 방법을 공식화한 형태로 표현한 것
- 문제풀이에 필요한 계산절차 또는 처리과정의 순서
- 같은 지식수준을 가진 사람이라면 그 알고리즘을 보고 누구나 같은 결과를 낼 수 있어야 한다
-> 보통 자료 구조가 선택되면 적용할 알고리즘은 거의 명확해짐
- 자료 구조와 알고리즘은 밀접한 관계


자료 구조의 선택 → 효율적인 알고리즘의 선택
넓은 의미에서 자료구조 + 알고리즘(+a) = 프로그램



Array(배열)
- 동일한 타입의 데이터들을 저장
- 고정된 크기를 가짐
- 다양한 정렬 알고리즘에서 사용 -> 배열을 일정한 순서로 저장할 수 있기 때문에 arr[0] = '가' arr[1] = '나'
장점 
- 인덱스를 이용한 빠른 접근
- 연속된 메모리 공간 사용 - 메모리 관리가 간단하고, 캐시 효율성이 높음 ?? 


Linked List(연결 리스트)
- 각 데이터 노드가 연결된 순차적 구조
- 노드 = key(데이터), next(다음 노드를 가리키는 포인터)
- 첫 번째 요소 : Head, 마지막 요소 : Tail
- ex) Alt + Tab을 사용하여 프로그램 간 전환, 갤러리

장점
- 동적인 데이터 추가/삭제에 유리 ->  동적으로 크기를 조절할 수 있어 메모리를 효율적으로 사용 -> 불필요한 공간 낭비x
- 삽입/삭제의 효율성 ->> 특정 위치에 요소를 삽입, 삭제할 때 다른 요소들을 이동시키지 않아도 됨

Stack(스택)
- 순서가 보존되는 선형 데이터 구조
- 가장 최근에 넣은 데이터부터 처리 LIFO(후입 선출)
- ex) 실행취소(undo), 재귀 프로그래밍에서 함수 호출 구현
장점
- 후입선출의 특성을 활용한 간단한 알고리즘 구현 용이
- 재귀 호출상황에서 유용하게 사용

Queue(큐)
- 가장 오래된 데이터를 먼저 처리 FIFO
- ex) 멀티스레딩에서의 스레드 관리, 대기열 시스템

Hash table(해시 테이블)
- 해시된 값을 색인(index)으로 삼아 키(key)와 데이터(value)를 저장하는 자료구조
- 데이터의 크기에 관계없이 삽입 및 검색에 매우 효율적 
- 테이블 안의 작은 그룹인 버킷에 키/값 쌍을 저장
- 해시 충돌이  자주 일어 날 수 있음
- ex) DB 인덱스 구현, 사용자 로그인 인증-> 패스워드를 해시해서 db에저장된 해시값과 같은지 비교, set 데이터 구조 구현

Hash table 종류
Direct Address Table
- 데이터를 배열의 인덱스로 사용하여 저장하는 방식으로 동작
- 탐색,삽입,삭제 연산 모두 O(1)
- 데이터의 크기가 매우 크거나 데이터가 sparse(희소한) 경우에는 적합하지 않음 -	> 배열의 크기가 매우 크거나, 배열의 일부분만 사용되고 나머지 부분은 빈 공간이 되기 때문에

Hash Table
- 해시된 해시값을 인덱스로 변환하여 키 값과 데이터를 저장하는 테이블
적재율
- 해시 테이블의 크기 대비, 키의 개수
- (키의 개수)/ (해시테이블 크기)
- Direct Address Table은 1이하, 적재율이 1 초과인 해시 테이블의 경우는 반드시 충돌이 발생
- 충돌X-> 탐색, 삽입, 삭제 연산 모두 O(1), 충돌 O -> 탐색, 삭제 연산 O(키의 개수)
- 해시함수로 도출된 값들이 같은 경우가 빈번하게 발생하게 되므로 잦은 충돌로 이어지게 됨

충돌 해결
해시 테이블 구조 개선
Chaining
- 충돌이 발생했을 때 이를 동일한 버킷(Bucket)에 저장하는데 이를 연결리스트 형태로 저장하는 방법
- 탐색과 삭제의 경우  O(키의 개수)가 걸림
Open Addressing
- 동일한 주소에 다른 데이터가 있을 경우 다른 주소를 이용하는 방법
- 삽입: 계산한 해시 값에 대한 인덱스가 이미 차있는 경우 다음 인덱스로 이동하면서 비어있는 곳에 저장 -> 비어 있는 곳을 찾는 것 = 탐사
- 탐색: 계산한 해시 값에 대한 인덱스부터 검사하며 탐사를 해나가는데 이 때 “삭제” 표시가 있는 부분은 지나감
- 삭제: 탐색을 통해 해당 값을 찾고 삭제한 뒤 “삭제” 표시

Open Addressing의 3가지 충돌 처리기법
선형탐사(Linear Probing)
- 바로 인접한 인덱스에 데이터를 삽입
- 데이터가 밀집되는 클러스터링(Clustering) 문제가 발생하고 이로인해 탐색, 삭제가 느림

제곱탐사(Quadratic Probing)
- 제곱탐사는 1의 제곱, 2의 제곱, 3의 제곱으로 탐사를 하는 방식
- 선형탐사에 비해 더 폭넓게 탐사하기 때문에 탐색,삭제 효율적
- 마찬가지로 클러스터링 문제가 발생할 수 있음

이중해싱(Double Hashing)
- 선형탐사와 제곱탐사에서 발생하는 클러스터링 문제를 모두 피하기 위해 도입된 것
- 처음 해시함수로는 해시값을 찾기 위해 사용하고 두번째 해시함수는 충돌이 발생했을 때 탐사폭을 계산하기 위해 사용되는 방식

해시 함수 개선
나눗셈법(Division Method)
- 해시 테이블의 크기를 알고 있는 경우 사용 가능
- 해시 테이블 크기로 데이터를 나눈 나머지를 해시값으로 사용하는 방법
- 나누는 값은 근처값인 소수를 사용

곱셈법(Multiplication Method)
- N(kA mod 1)   (0< A< 1)
- kA mod 1은 소수점 이하 부분을 말하며, 이를 테이블 크기(N)에 곱하여 0부터 N사이의 값이 됨
- N이 어떤 값이라도 잘 동작하며 A를 잘 설정하는 것이 중요
Graph(그래프)
- 노드 사이에 엣지가 있는 collection = (여러 개의 데이터를 모아서 저장하고, 관리하는 자료구조)
	- 배열과 달리, 컬렉션은 동적으로 크기를 조절할 수 있으며, 더 이상 필요하지 않은 데이터는 자동으로 해제
	- 자주 사용되는 연산을 제공
	- 배열과 달리, 다양한 자료형의 데이터를 저장
	- Java에서는 ArrayList, LinkedList, HashSet, TreeMap 등
- directed(방향)- 단방향, undirected(무방향)- 양방향 이 존재
- 트리에 사이클이 존재할때의 형태
- ex) 소셜 미디어 네트워크를 나타내는데 사용, 검색 엔진에 의해 웹 페이지(노드) 및 링크(엣지)를 나타내는데 사용, GPS에서 위치와 경로를 나타내는데 사용- 그래프 알고리즘으로 경로 최적화,  GPS 좌표 - 노드
장점
- 다양한 관계 표현 가능 - 현실세계의 복잡한 관계를 모델링하기 적합
- 유연한 연결성 - 그래프는 노드와 간선을 구성되어 있어, 다양한 형태의 연결성을 표현 가능
- 네트워크 및 경로 탐색 - 네트워크 모델링이나 최단 경로, 최소 스패닝 트리 등의 문제를 효율적으로 해결

Tree(트리)
- 그래프가 계층적 구조를 가진 형태 ,사이클 X
- 최상위 노드(루트)를 가지고 있음
- 상위 노드 = 부모(Parent) 노드, 하위 노드 = 자식(Child) 노드
- ex) 
Binary Trees(이진트리),
- 각 노드가 최대 2개의 자식 노드를 가지는 트리 구조
Binary Search Tree(이진 검색 트리),
- 이진 트리의 한 종류로, 각 노드의 값이 그 왼쪽 서브트리의 모든 값보다 크고, 그 오른쪽 서브트리의 모든 값보다 작음
Heap(힙) 
Tree 장점
- 계층 적인 구조
- 빠른 검색 및 삽입
- 이진 검색 트리(Binary Search Tree)는 데이터를 정렬된 상태로 저장하므로, 정렬된 데이터를 검색하는 데에 효율적
- 데이터의 동적 크기 조절


Heap(힙) 
- 이진 트리의 일종으로, 특별한 조건을 만족하는 완전 이진 트리
- 부모 노드가 자식 노드보다 우선순위가 높은 구조
- 힙은 일반적으로 배열을 이용하여 구현
- 최대 힙(Max Heap)과 최소 힙(Min Heap) 두종류가 있음
- 최대 힙에서는 루트 노드가 가장 큰 값이며, 자식 노드의 값은 부모 노드의 값보다 작거나 같아야함
- ex)
힙 정렬 알고리즘, 
- 입력 배열의 끝에서부터 시작하여 부모 노드와 자식 노드를 비교하면서 큰 값을 부모 노드로 이동시키는 과정을 반복
우선순위 큐
- 데이터들이 우선순위를 가지고 있고, 이를 기준으로 높은 우선순위의 데이터가 먼저 처리되는 자료구조
장점
- 우선순위 큐를 구현하는 데에 효과적으로 사용
- 동적 메모리 할당하므로 데이터의 동적 크기 조절이 가능

https://bnzn2426.tistory.com/115
